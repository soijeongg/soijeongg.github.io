---
layout: post
read_time: true
show_date: true
title: "[항해 99] 주특기 1차 과제"
date: 2024-02-20 15:00:20 -0600
description: "[항해 99] 주특기 1차 과제"
image: https://hanghae99.spartacodingclub.kr/images/main/og.jpg
tags: 
    - coding
    - diary
    - hh99
author: soi

toc: no # leave empty or erase for no TOC
---
### DOM

1. 자바스크립트가 생긴 이유?
자바스크립트는 브라우저에서 쓰려고 만들어졌다 
웹페이지를 동적으로 만들기 위해 만들어짐

2. 웹페이지의 파싱과정
1) 사용자가 브라우저에게 url을 입력해 요청
2) url 마지막 부분부터 DNS서버에서 검색
(www.naver.com이면 com->naver 이렇게 들어감)
3)DNS서버는 그에 해당하는 ip주소 반환
4) 이 ip주소에 해당하는 서버에 있는 html페이지 가져옴
5)html 문서를 랜더링 함
html파일과 css파일을 각각 파싱해 tree를 만든다(Parsing)
두 tree를 결합하여 실제 화면에 그려질 tree인 Rendering Tree를 만든다(Style)
랜더링 트리에서 각 노드의 위치와 크기를 계산한다(Layout)
계산 된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환, 레이어를 만든다(Paint)
레이어를 합성해 화면에 나타낸다

3. DOM 이란?
![](https://velog.velcdn.com/images/soijeongg/post/4136d2f1-2658-435d-810e-6c1c404cbe08/image.png)

Document Object Modeling(DOM)
- Document(html)파일을 자바스크립트가 알아들을 수 있는  객체형태(object)로 모델링 한것
- 브라우저에 기본적으로 내장된 API중 하나
- DOM이 브라우저에 내장되어있기 때문에 우리는 HTML의 내용을 javascript로 접근, 제어가 가능
- 모든 DOM들은 속성과 메서드들을 가지고 있다 
속성은 해당 객체의 특성값을 가져오거나 설장
메서드는 해당 객체가 수행하는 작업을 나타냄
(파이썬의 클래스 안 필드와 메서드 라고 생각)
- DOM의 노드란 html의 모든 요소들을 하나의 블록으로 취급
![](https://velog.velcdn.com/images/soijeongg/post/25d90c2a-4a13-4866-aea7-cd2cfa4c8ac0/image.png)


4. api 란
- api란? Application Programing Interface로 서비스 요청과 응답을 처리하는 서비스
- 다른 소프트 웨어 구성요소 혹은 서비스와 상호작용 하기 위한 인터페이스를 제공
- api는 서버 와 데이터 베이스에 대한 출입구 역할을 한다
- api는 프로그램의 명령 목록을 정리하고 응용 프로그램과 상호작용 해 값을 전달
 ![](https://velog.velcdn.com/images/soijeongg/post/79ea10d1-6b37-464f-83ac-54dcdceb5fea/image.png)
 
 5. DOM에 접근 및 제어해보기
 돔트리의 최상단 노드는 document 
 ```javascript
// 무슨 결과가 나올까요?
document.getRootNode();
```
하면 출력으로 HTMLDocument { <html> } 이게 나온다
  ```
document 관련 api
  - Finding
  
```javascript
  /** 찾아봅시다 */

// 해당 id명을 가진 요소 하나를 반환합니다.
document.getElementById("id명")

// 해당 선택자를 만족하는 요소 하나를 반환합니다.
document.querySelector("선택자")

// 해당 class명을 가진 요소들을 배열에 담아 인덱스에 맞는 요소를 반환합니다.
document.getElementsByClassName("class명")[인덱스]

// 해당 태그명을 가진 요소들을 배열에 담아 인덱스에 맞는 요소를 반환합니다.
document.getElementsByTagName("태그명")[인덱스]

// 해당 선택자를 만족하는 모든 요소들을 배열에 인덱스에 맞는 요소를 반환합니다.
document.querySelectorAll("선택자명")[인덱스]

// 새로운 노드를 생성합니다.
const div = document.createElement('div');
document.body.append(div);
document.body.append(div);
```

- chaning 
```javascript
  /** property(=속성)을 바로 바꿔버려잇! */

// 이 둘은 차이가 있어요!
element.innerHTML = new html content
element.innerText = new text

// style을 바꿔요.
element.style.property = new style

//method를 통해 클래스를 추가해봐요.
element.setAttribute(attribute, value)

// 어랏? 그럼 이런것도 가능??
element.setAttribute("style", "background-color:red;");

// ....
element.style.backgroundColor = "red";

// input 필드의 변신
  ```
innerHTML은 아예 태그 까지 넣어주는 거고 
  innertext는 그냥 안의 내용만 바꾸는것

- 더해보기
``` javascript
  // createElements
const para = document.createElement("p");
para.innerText = "This is a paragraph";
document.body.appendChild(para);

// createTextNode(elements는 아니구여, 그냥 글자...)
let textNode = document.createTextNode("Hello World");
document.body.appendChild(textNode);

// write. 조심 또 조심!
document.write("Hello World!");

document.write("<h2>Hello World!</h2><p>Have a nice day!</p>");

// 골로 가는 코드
function myFunction() {
  document.write("Hello World!");
}

// version 01
element.addEventListener("click", myFunction);
function myFunction() {
  document.getElementById("demo").innerHTML = "Hello World";
}

// version 02
element.addEventListener("click", function() {
  document.getElementById("demo").innerHTML = "Hello World";
});
```
  
  ### class
  자바스크립트에서 클래스 문법은 es6에서야 도입
  
  1. 클래스와 인스턴스의 개념
  보통 클래스를 설명할때는 붕어빵 틀
  인스턴스 설명할때는 그걸로 만든 붕어빵
  붕어빵은 붕어빵 틀의 모양을 따라 만들어지지만 안의 내용물을 바꿀 수 있는 것처럼 인스턴스도 내용 추가 가능
  
  2.Class란?
  class는 객체를 생성하기 위한 일종의 템플릿
  Class를 생성하기 위해서 class라는 키워드 사용
```javascript
  class Person {
	// constructor는 이름을 변경할 수 없어요.
  constructor(name, age) {
		// 이름(name)과 나이(age)가 없으면 사람이 아니죠?
		// new라는 키워드를 이용해서 인스턴스를 만들 때, 기본적으로
		// 넣어야 하는 값들을 의미해요! :)
		// 여기서 말하는 this는 만들어질 인스턴스를 의미한다고 생각해주세요!
    this.name = name;
    this.age = age;
  }

	// 다양한 메소드를 아래와 같이 정의할 수 있어요.
	// 여기서 this.name으로 내부 값을 접근해야 함을 잊지 마세요! :)
  sayHello() {
    console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
  }
}

const person1 = new Person("Alice", 30);
const person2 = new Person("Bob", 25);

// 만든 객체를 토대로 메서드 호출해보기
person1.sayHello(); // 출력: "Hello, my name is Alice and I am 30 years old."
person2.sayHello(); // 출력: "Hello, my name is Bob and I am 25 years old."
```
파이썬에서 클래스 인스턴스와 같음
  
  - Constructor란?
  Constructor는 Class의 생성자 함수
  객체를 초기화하는 역할(이게 그럼 파이썬의 __init__이야??)
``` javascript
  class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
  }
}

const person = new Person('Alice', 20);
```
  
2.  Getter와 Setter
  Class에서는 getter와 setter를 사용하여 Class의 속성에 접근
getter는 속성 값을 반환하는 메소드
setter는 속성 값을 설정하는 메소드

```javascript
  // Getters와 Setters
// 객체지향 프로그래밍 언어 -> G, S
// 클래스 --> 객체(인스턴스)
// 프로퍼티(constructor)
// new Class(a, b, c)
class Rectangle {
  constructor(height, width) {
    // underscore : private(은밀하고, 감춰야 할 때)
    this._height = height;
    this._width = width;
  }

  // width를 위한 getter
  get width() {
    return this._width;
  }

  // width를 위한 setter
  set width(value) {
    // 검증 1 : value가 음수이면 오류!
    if (value <= 0) {
      //
      console.log("[오류] 가로길이는 0보다 커야 합니다!");
      return;
    } else if (typeof value !== "number") {
      console.log("[오류] 가로길이로 입력된 값이 숫자타입이 아닙니다!");
      return;
    }
    this._width = value;
  }

  // height를 위한 getter
  get height() {
    return this._height;
  }

  // height를 위한 setter
  set height(value) {
    // 검증 1 : value가 음수이면 오류!
    if (value <= 0) {
      //
      console.log("[오류] 세로길이는 0보다 커야 합니다!");
      return;
    } else if (typeof value !== "number") {
      console.log("[오류] 세로길이로 입력된 값이 숫자타입이 아닙니다!");
      return;
    }
    this._height = value;
  }

  // getArea : 가로 * 세로 => 넓이
  getArea() {
    const a = this._width * this._height;
    console.log(`넓이는 => ${a}입니다.`);
  }
}

// instance 생성
const rect1 = new Rectangle(10, 7);
rect1.getArea();
// const rect2 = new Rectangle(10, 30);
// const rect3 = new Rectangle(15, 20);
```
_를 사용해서 접근제어자중 private를 구현
height, width 두개를 provater로 만듬
가져오기 위한 get에 return
지금 width값을 검증하기 위해 set사용
  
  
3. 연습해보기
  
```javascript
  // 클래스 연습해보기!
// [요구사항]
// 1. Car라는 새로운 클래스를 만들되, 처음 객체를 만들 때는
//    다음 네 개의 값이 필수로 입력돼야 합니다!
//    (1) modelName
//    (2) modelYear
//    (3) type : 가솔린, 전기차, 디젤
//    (4) price
// 2. makeNoise() 메서드를 만들어 클락션을 출력해주세요.
// 2-1. 해당 자동차가 몇년도 모델인지 출력하는 메서드 작성!
// 3. 이후 자동차를 3개 정도 만들어주세요(객체 생성)

// [추가 요구사항]
// 1. modelName, modelYear, price, type을 가져오는 메서드
// 2. modelName, modelYear, price, type을 세팅하는 메서드
// 3. 만든 인스턴스를 통해서 마지막에 set 해서 get 하는 로직까지
class Car {
  constructor(modelName, modelYear, type, price) {
    this._modelName = modelName;
    this._modelYear = modelYear;
    this._type = type;
    this._price = price;
  }

  get modelName() {
    return this._modelName;
  }

  // 입력값에 대한 검증까지 가능하다
  set modelName(value) {
    // 유효성 검사
    if (value.length <= 0) {
      console.log("[오류] 모델명이 입력되지 않았습니다. 확인해주세요!");
      return;
    } else if (typeof value !== "string") {
      console.log("[오류] 입력된 모델명이 문자형이 아닙니다!");
      return;
    }

    // 검증이 완료된 경우에만 setting!
    this._modelName = value;
  }

  get modelYear() {
    return this._modelYear;
  }

  set modelYear(value) {
    // 유효성 검사
    if (value.length !== 4) {
      // 연도에 대한 유효성 검증 로직 ---> googling 엄청~~~~많이 나옵니다!!
      console.log("[오류] 입력된 년도가 4자리가 아닙니다.확인해주세요!");
      return;
    } else if (typeof value !== "string") {
      console.log("[오류] 입력된 모델명이 문자형이 아닙니다!");
      return;
    }

    // 검증이 완료된 경우에만 setting!
    this._modelYear = value;
  }

  get type() {
    return this._type;
  }

  set type(value) {
    if (value.length <= 0) {
      console.log("[오류] 타입이 입력되지 않았습니다. 확인해주세요!");
      return;
    } else if (value !== "g" && value !== "d" && value !== "e") {
      // g(가솔린), d(디젤), e(전기차)가 아닌 경우 오류
      console.log("[오류] 입력된 타입이 잘못되었습니다. 확인해주세요!");
      return;
    }

    // 검증 완료!
    this._type = value;
  }

  get price() {
    return this._price;
  }

  set price(value) {
    if (typeof value !== "number") {
      console.log("[오류] 가격으로 입력된 값이 숫자가 아닙니다. 확인해주세요!");
      return;
    } else if (value < "1000000") {
      console.log("[오류] 가격은 100만원보다 작을 수 없습니다. 확인해주세요!");
      return;
    }

    // 검증이 완료된 경우
    this._price = value;
  }

  // 클락션을 울리는 메서드
  makeNoise() {
    console.log(this._modelName + ": 빵!");
  }

  // 해당 자동차가 몇년도 모델인지 출력하는 메서드 작성!
  printModelYear() {
    console.log(
      this._modelName + "은 " + this._modelYear + "년도의 모델입니다."
    );
  }
}

// 자동차 만들기
const car1 = new Car("Sorento", "2023", "e", 5000);
const car2 = new Car("SM5", "1999", "g", 3000);
const car3 = new Car("Palisade", "2010", "d", 4500);
// car1.makeNoise();
// car1.printModelYear();
// car2.makeNoise();
// car2.printModelYear();
// car3.makeNoise();
// car3.printModelYear();

// getter 예시1
console.log(car1.modelName);
// setter 예시1
car1.modelName = 1;
console.log(car1.modelName);
```
3. 상속(Inheritance)
  Class는 상속을 통해 다른 Class의 기능을 사용할 수 있음
상속을 받는 Class를 subclass 또는 derived class
상속을 하는 Class를 superclass 또는 base class
``` javascript
  // 동물 전체에 대한 클래스에요
class Animal {

	// 이름을 필수로 받아야 해요
  constructor(name) {
    this.name = name;
  }

	// 동물의 행동을 정의하는 메소드
  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

// 동물 클래스를 상속받는 Dog 클래스를 만들어요
class Dog extends Animal {
	// 상속받을 때, speak()를 입맛에 맞게 재정의해요.
  speak() {
    console.log(`${this.name} barks.`);
  }
}

// Dog를 만들 때는 Animal의 상속을 받은 class이기 때문에 이름을 필수로
// 받아야 해요!
let d = new Dog('Mitzie');

// speak는 'makes a noise'가 아니라, 'barks'가 출력되네요.
d.speak(); // "Mitzie barks."
```
extends를 확장하다라는 뜻 
class subclass extends superclass 이렇게 사용한다
상속받을때 안의 메서드를 다시 재정의 할 수 있다
Dog Class에서 speak 메소드를 오버라이딩하여 Animal Class의 speak 메소드를 덮어씀
  
- 오버라이딩, 오버로딩
  오버라이딩이란 상위 클래스에서 정의된 메서드를 하위 클래스에서 동일한 이름의 메서드로 다시 정의하는 것
  
 오버로딩이란  동일한 이름의 메서드를 여러 개 정의하되, 매개변수의 유형, 개수, 순서가 다르게 정의하는 것
  
- super란?
  상위 클래스의 생성자 또는 메서드에 접근하기 위해 사용
  super()를 호출하면 상위 클래스의 생성자가 실행
  상위 클래스의 멤버 변수나 초기화 코드를 실행
  오버라이딩된 메서드가 아닌 상위 클래스의 메서드를 호출
  
4. static Method
  Class에서는 static 키워드를 사용하여 Class 레벨의 메소드를 정의
  Class 레벨의 메소드는 인스턴스에서 호출할 수 없으며, Class 이름으로 직접 호출
  
  인스턴스를 만들지 않고 사용할 수 있기 때문에 복제할 필요가 없는 데이타(똑같은 걸 공유해서 쓸때) 사용
 **특정 클래스의 인스턴스를 만들지 않고도 호출할 수 있는 메서드**
인스턴스 간에 복제할 필요가 없는 데이터(똑같은 것을 공유해서 쓸 때)를 만들 때 사용
  
  
### 클로져
클로져는 함수와 그 함수가 선언된 렉시컬 환경과의 조합
  - 렉시컬 환경이란?
  함수가 정의될때 생기는 실행컨텍스트에 담김
  현재 컨텍스트 내부에는 식별자들이 있고 어떻게 하도록 구성이 되어있다 라는 환경정보를 사전에서 접하는 느낌으로 모아놓은것
실시간으로 변경 사항이 계속해서 반영
  
- 함수가 선언된 렉시컬 환경
```javascript
  const x = 1;

function outerFunc() {
  const x = 10;
  function innerFunc() {
    console.log(x); // 10
  }

  innerFunc();
}

outerFunc();
```
outerFunc()가 호출 되면 위에 선언되어 있던 outerFunc()의 x가 10이 됨 
innerFunc()가 콘솔로그로 정의 그리고 호출 시 
먼저 스코프 내부의 x값을 찾음
  만약 없다면 scope chain에 의해 바로 바깥쪽 scope를 찾음 -> outer를 찾는것
outer는 해당 실행컨텍스트의 생성시점의 LexicalEnvironment를 가지고 있음
  
만약 아래와 같다면 어떻게 나올까?
  
  ``` javascript
  const x = 1;

// innerFunc()에서는 outerFunc()의 x에 접근할 수 없죠.
// Lexical Scope를 따르는 프로그래밍 언어이기 때문
function outerFunc() {
  const x = 10;
  innerFunc(); // 1
}

function innerFunc() {
  console.log(x); // 1
}

outerFunc();
  ```
outerFunc와, innerFunc는 서로 다른 scope를 가지고 있다 -> **변수 공유X**

정의 후 outerFunc()호출
안에서 x를 10으로 정의하고 innerFunc 호출
하지만 Lexical Scope를 따르는 언어이기 때문에 내부에서 호출한다 하더라도 outerFunc 함수의 변수에 접근 할 수 없음
  
#### 렉시컬 스코프
자바스크립트는 어디서 호출했는지가 아니라 **어디에서 정의했는지**에 따라 상위스코프를 결정
외부 렉시컬 환경에 대한 참조에 저장할 참조값
스코프에 대한 참조는 함수 정의가 평가되는 시점(코드가 실행되는 시점)에 함수가 정의된 환경
  
- 정의돈 환경에 대한 정보를 저장하는곳
  outer
  함수가 정의된 환경과 함수가 호출된 환경을 다를 수 있다
 호출되는 환경과는 상관없이 정의된 환경에 대한 정보를 LexicalEnvironment > outer에 기억
  **호출된 위치와 상위 스코프는 아무 관계가 없다**
  
- 클로져와 렉시컬 환경
외부 함수보다 중접 함수가 더 오래 유지되는 경우, 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 (여전히) 참조 가능
  
중첩 함수는 함수 내에서 정의된 함수 
중첩함수는 외부 함수 안에 있다 
  
"중첩 함수가 외부 함수보다 오래 유지되는 경우"란
중첩 함수가 외부 함수의 실행이 끝난 후에도 계속해서 사용될 수 있는 경우
  
- 중첩함수가 외부함수의 실행이 끝난 후에도 계속해서 사용될 수 있는 경우
  중첩 함수가 외부 함수의 반환 값으로 사용되는 경우
   중첩 함수가 외부 함수 내부에서 외부 함수의 변수를 참조하고 있고, 이 중첩 함수가 외부 함수 외부에서 사용되는 경우 
  
  **여기서 중첩함수가 클로져**
  
``` javascript
  const x = 1;

// 1
function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

const innerFunc = outer();
innerFunc();
```
  
지금보면 외부함수에서 내부함수를 반환
그리고 outer함수의 실행컨텍스는 실행됐으니 제거
return 된 inner함수를 런타임이 평가 
inner함수가 innerFunc에 전달되었는데, 이는 outer 함수의 렉시컬환경을 (여전히) 참조
  
**outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다**
  
- 이게 가능한 이유?
  가비지 컬렉터는 안쓰는 것만 가져감 
  근데 사용이 끝난 함수의 렉시컬 환경이 참조하는 곳이 있으면 놔둠
  
- 클로져와 클로져가 아닌것
  중첩함수가 상위 스코프의 식별자를 참조하지 않으면 ㅅ클로져라고 하지 않음
  (상위 함수의 렉시컬 환경을 참조하지 않음> 가비지 컬렉터가 참조하는 곳ㅇ리 없으니 삭제)
  
 ### 클로져의 활용
  클로져는 주로 상태를 안전하게 은닉하고 유지하기 위해 사용
  
- 예제
``` javascript
  // 카운트 상태 변경 함수 #1
// 함수가 호출될 때마다 호출된 횟수를 누적하여 출력하는 카운터를 구현해요!

// 카운트 상태 변수
let num = 0;

// 카운트 상태 변경 함수
const increase = function () {
    // 카운트 상태를 1만큼 증가시킨다.
    return ++num;
};

console.log(increase());
// num = 100; // 치명적인 단점이 있어요.
console.log(increase());
console.log(increase());
```
보완 사항
카운트 상태의 값은 increase함수가 호출 전까지 변경 하지 않고 유지 되어야 함
  -> 다른 곳에서 접근이 금지 되어야 함
  -> 오직 increase 함수만 변경이 가능해야 한다
그래서 0을 함수 안으로 넣으면 매번 초기화 된다 
 -> **의도치 않는 변경은 방지하면서 이전 상태를 유지 해야함**
-> 클로져를 사용하기

``` javascript
  // 카운트 상태 변경 함수 #3
const increase = (function () {
  // 카운트 상태 변수
  let num = 0;

  // 클로저
  return function () {
    return ++num;
  };
})();

// 이전 상태값을 유지
console.log(increase()); //1
console.log(increase()); //2
console.log(increase()); //3
```
  
위 코드 실행시 함수가 즉시 호출되고 즉시 실행 함수가 반환한 함수 increase가 할당
이 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억
 
### 캡슐화
  캡슐화란 프로퍼티와 메서드를 하나로 묶는 것을 말함
  객체의 특정 프로퍼티와 메서드를 감출 목적으로 사용
  es2022부터 들어온 private-> #으로 사용 가능
  
  ``` javascript
  // 생성자 함수
function Person(name, age) {
  this.name = name; //public
  let #age = age; //private

  // 인스턴스 메서드
  // 따라서, Person 객체가 생성될 때 마다 중복 생성됨
  // : 해결방법 -> prototype
  this.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${#age}.`);
  };
}

const me = new Person("Choi", 33);
me.sayHi(); // Hi!, My name is Choi. I am 33.
console.log(me.name); // Choi
console.log(me.#age); // undefined

const you = new Person("Lee", 30);
you.sayHi(); // Hi! My name is Lee. I am 30.
console.log(you.name); // Lee
console.log(you.age); // undefined
```
funcs[i]에는 함수가 할당되고, 그 함수는 매개변수 id를 받음
그리고 그 함수는 클로저를 형성하여 id 값을 기억
클로저가 반환하는 것은 새로운 함수
새로운 함수는 매개변수 없이 호출되며, 클로저에서 기억한 id 값을 반환
  
근데 그러면 [id, id, id]가 들어가게 되고 
  그래서 두번째가 그 길이만큼 도니까 더 직관적으로 할려면 그 i값을 리턴해서 넣기 
  ``` javascript
  var funcs = [];

for (let i = 0; i < 3; i++) {
	funcs[i] = function() { return i; };
}

for (let i = 0; i < funcs.length; i++) {
	console.log(funcs[i]()); // 0 1 2
}
```
  
  