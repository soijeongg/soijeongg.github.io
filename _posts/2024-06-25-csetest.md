---
layout: post
read_time: true
show_date: true
title: "벡엔드 면접 대비 cs 질문 정리"
date: 2024-06-25 25:00:20 -0600
description: "벡엔드 면접 대비 cs 질문 정리 "
image: https://i.pinimg.com/564x/1e/08/92/1e089238ec4fa4629a4988aca72fba90.jpg
tags: 
    - coding
    - cs
author: soi

toc: no # leave empty or erase for no TOC
---
## cs관련 지식

- 네트워크 

#### 브라우저에 url 입력하면 일어나는 일
특정 웹사이트에 접속하기 위해서는 구글이나 네이버 같은 도메인이 아니라 ip주소를 입력해야한다 
하지만 ip주소는 길고 가독성이 떨어지기 때문에 아이피 주소가 아닌 이 아이피 주소와 매칭해놓은 DNS서버를 사용한다 
DNS는 도메인 네임 시스템의 약자로 도메인과 아이피 주소를 저장하고 있는 서버이다 

- 1. 브라우저는 DNS 서버에 접속하기 전에 캐싱한 DNS 기록을 통해 해당 도메인 주소와 연결된 아이피주소가 있는지 확인한다 
- 2. 있다면 그 아이피 주소로 이동한다   만약 없다면 http를 통해 dns서버에 입력된 도메인 서버를 요청한다 
dns 이름의 가장 높은 계층인 루트 도메인 부터 시작해 점점 아래로 내려간다 
루트도메인(.)
최상위도메인(com, net, kr, jp)
두번째 수준 도메인(google.com, naver.com)
세번째 수준 도메인(www.goole.com, www.naver.com)
이렇게 찾아가 아이피 주소를 찾는다 

- 3. 연결이 되면 브라우저는 get요청을 해 해당 아이피 주소의 웹페이지를 요청헌다 

- 4. 서버는 html문서를 브라우저에 응답하고 브라우저는 html을 파싱해 렌더링을 하고 리소스를 요청한다 

- 5. 모든 리소스가 로드되면 웹페이지에 접근할 수 있다 

***
#### tcp와 udp의 차이점
tcp는 전송제어 프로토콜로 인터넷 상에서 아이피 규칙으로만 통신하기에는 부족하거나 불안정한 단점들을 커버해 전송을 제어하며 신뢰성을 보장한다
 tcp는 연결지향적으로 3 way handshaking 과정을 통해 송신자와 수신자간의 연결을 설정한다 
 tcp는 데이터패킷이 손실이나 손상되지 않도록 보장한다 확인 응답(ACK)를 통해 데이터가 올바르게 수신되었는지 확인하고 손실된 패킷은 재전송한다 
 또한 송신자가 수신자의 처리능력을 초과하지 않도록 데이터 전송 속도를 조정한다 

 udp는 사용자 데이터그램 프로토콜로 신뢰성보다 속도를 중시하는 응용프로그램에 사용된다 
 udp는 최소한의 프로토콜 메커니즘을 갖춘 간단한 무연결 통신모델로 서로 주고받을때 정보를 보내거나 신호전송 절차를 거치지 않고 보내는쪽에서 일방적으로 데이터를 전달하는 통신 프로토콜이다 
 udp는 비연결지향적이며 패킷이 손실되거나 손상될 가능성이 있고 순서를 보장하지 않는다 
 ***
#### 클라이언트 사이드 랜더링과 서버사이드 랜더링의 차이 
- 클라이언트 사이드 랜더링
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbtPuR2%2Fbtq6QPMRbme%2FK7Wxl8UVD9RQOpTrwPNFb0%2Fimg.png)


브라우저에서 자바스크립트를 사용하여 페이지의 콘텐츠를 동적으로 랜더링하는 방식
클라이언트(브라우저)가 맡아서 하는 방식  -> 서버에서 받은 데이터를 클라이언트인 브루우저가 화면에 그린다 
html파싱부터 자바스크립트 읽기를 전부 브라우저에서 하기 때문에 시간이 더 걸림


초기 로드 속도는 느리지만 이후 서버와의 상호작용이 줄어들고 브라우저 내에서 상태변경이 일어나기 떄문에 이후 페이지 전환 속도는 빠르다 
검색엔진 최적화에는 보완이 필요하다 

- 서버사이드 랜더링
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJZIai%2Fbtq6Ra4gq0H%2FGBazRjuUIOQ2EuTKb6k4W1%2Fimg.png)


서버쪽에서 화면을 랜더링하여 보여주는 방식
서버로부터 완전한 html파일을 받아 화면을 구성하기 때문에 첫화면 로딩 속도가 빠르다 
이후 페이지전환시에는 서버로부터 새로운 페이지를 받아야 해 전환속도가 느리다 
검색크롤러가 서버에 렌더링된 html을 바로 인덱싱이 되 검색엔진 최적화가 가능하다  


서버는 네트워크가 느리거나 검색엔진 최적화가 필요할떄, 페이지의 상호작용이 별로 없을떄 
클라이언트는 네트워크가 빠르거나 검색엔진 최적화가 필요 없을때 페이지의 상호작용이 많이 필요할때 사용한다 

*** 
#### call by value/ call by Reference의 차이
 - call by value

 값에 의한 호출 -> 함수에 변수를 전달 할때 그 변수의 값을 복사해 전ㅁ달
 함수내에서 변수의 값을 변경해도 원래 변수의 값에서는 영향을 미치지 않음
 함수 외부 내부가 독립적임


 - call Reference

 참조에 의한 호출이라고 하며 함수에 변수를 전달할떄 변수의 참조 또는 주소를 전달
함수내에서 참조된 변수의 값을 변경하면 원래 변수의 값도 함꼐 변경된다 
내부와 외부가 연결되어있다 


call by value 방식은 함수가 호출될때 값의 복사가 이루어져 메모리가 더 쓰이지만 안전하게 작동할 수 있다 
call by Referenece 방식은 메모리 효츌적이지만 실수로 원본 데이터를 변경할 위험이 있다 

***
#### 모놀리식 아키텍쳐/ 마이크로 서비스 

모놀리식 아키텍쳐는 애플리케이션이 모든 기능이 하나의 단일 코드베이스와 하나의 배포단위에 통합도어 있는 것을 의미함
모든 기능들이 하나의 시스템에서 동작하므로 환경세팅에 시간이 적게 들고 모든 기능들이 하나의 시스템에서 동작하기 때문에 테스트가 쉽다 

하지만 코드가 무수히 많아지면 코드의 가독성이 떨어지고 이해하는데 시간이 올리걸리기 떄문에 유지보수가 어렵다 
특정기능에 오류가 발생하면 전체 시스템에 그 영향이 가 전체 시스템에 오류가 발생하게 된다 

마이크로 서비스는 서비스가 커질수록 시스템이 무거워지는 모놀리식의 단점을 해결하기 위해 여러 모듈을 조합하여 애플리케이션을 구현하는 방식으로 개발부터 배포까지 효율적으로 수행할 수 있다 


시스템이 독립적으로 구성되어 있기 때문에 이해해야 하는 코드의 수가 적고 유지보수가 쉽다 
서비스가 독립적으로 나눠져 있기때문에 효율적으로 개발과 배포가 가능하다 
하지만 관리해야하는 복잡성이 증가하고 서비스가 독립적으로 실행되므로 인프라 비용이 증가한다 

#### 프록시 서버 
프록시 서버는 클라이언트와의 서버간의 중계 역핧을 수행하는 서버이다 
프록시 서버를 사용하게 되면 클라이언트가 네트워크 상에서 다른 서버로 직접 연결하지 하지 않고 중간에 프록시 서버를 경유하여 통신하게 된다 

#### Rest api
rest api는 소프트웨어 프로그램 아키텍쳐의 한 형식으로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든것을 의미합니다 

기본적으로 기존 기술과 http 프로토콜을 그대로 사용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍쳐 스타일입니다 


url을 통해 자원을 명시하고 http method를 통해 해당자원에 대한 CRUD OPERATION을 적용한다 

장점으로는 HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하고 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다 


- api
api는 프로그램간에 서로 정보를 교환가능하도록 한다 
restapi는 restㅇ를 기반으로 api를 구현한것이다 

#### 프로세스와 스레드 
프로세스는 운영체제로부터 자원을 할당받은 작업의 단위이고 스레드는 프로세스가 할당받은 자원을 이용하는 실행흐륾의 단위
프로세스는 프로그램을 시켜 정적인프로그램이 동적으로 변하여 돌아가고 있는 상태
캄퓨터에서 작업중인 프로그램을 의미 
원래는 프로세스 하나만 사용했지만 기술 발전으로 인해 프로세스 사용에는 한계가 생겨 하나의 프로세스 안에서 동시에 진행되는 흐름의 단위로 여라기 작업들의 흐름이 동시에 진행된다 
같은 프로세스 내에서 실행되는 스레드들은 동일한 메모리 공간을 공유해 자원을 공유한다 

***
#### IoC와 DI
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FKLypj%2Fbtr6g85SQKx%2FukyCnY2tQAdbbK088AJU51%2Fimg.png)
IoC는 제어의 역전으로 프로그램의 흐름을 개발자가 아닌 외부에서 관리되는 것입니다 
객체간의 결합도를 줄이고 유연한 코드를 작성할 수 있게 되어 유지보수가 편하게 된다

IoC는 DI와 DL로 나눠집니다 
DI는 의존성 주입으로 객체간의 의존성을 개발자가 내부에서 new 를 사용해 직접 호출하는게 아닌 외부에서 객체를 생성해 넣어주는 방식으로 테스트와 유지보수가 쉬워집니다

DL은 의존성 검색으로 객체가 필요로 하는 의존성을 외부컨테이너로부터 가져오는 방식으로 객체가 의존성을 요청하고 외부 컨테이너가 제공합니다 



***
### 보안
#### JWT에 대해 
jwt는 json web token의 줄임말로 json 객체에 인증이 필요한 정보들을 담아 비밀키로 서명한 토큰
사용자가 로그인 요청을 보내면 서버는 비밀키를 이용해 토큰능ㄹ 발금하고 이 토큰을 헤더에 담아 클라이언트에 보낸다 
그 후 클라이언트는 jwt를 로컬에 저장한 후 api 호출이 올때마다 헤더에 토큰을 담아 보내고 서버는 헤더를 확인해 사용자의 신원을 파악하고 인증이 되면 api 응답을 보낸다 
매번 헤더에 보내야 하는 이유는 http가 Connectionless하고 Stateless해 한번 통신이 일어난 뒤 연결이 끊어지고 이전 상태를 유지 하지 않아 과거에 어떤 정보를 보냈는지 기억하지 못한다는 점 때문이다 

OAuth는 제3자 인증방식으로 사용자가 신뢰할 수 있는 서버에 정보를 맞겨 놓고 접근 할 수 있는 권한을 주는것이다 
사용자측에서도 민감한 정보를 굳이 입력받지 않아도 되고 서버측에서도 민감 정보를 굳이 관리하지 않아도 되는 장점이 있다 

#### 세션 vs 쿠키 vs 캐시 
http의 특징은 Connectionless하고 Stateless하기 때문에 클라이언트가 누구인지 확인해야 하기 때문에 쿠키와 세션을 사용한다 

- 쿠키 
쿠키는 클라이언트에 저장되는 키와 값이 같이 들어있는 데이터 파일로 사용자가 인증이 유효한 시간을 명시할 수 있으며 유효시간이 정해지면 브라우저가 종료되도 인증이 유지된다는 특징이 있다 
클라이언트의 상태를 로컬에 저장후 참조한다 
쿠키는 클라이언트에 저장되므로 xss와 같은 공격에 취약 할 수 있다 

- 세션
쿠키 기반이지만 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 서버측에서 관리 
서버는 클라이언트를 구분하기 위해 세션 아이디를 부여함
브라우저가 서버에 접속해서 브라우저가 종료할때까지 인증 상태를 유지 한다 
사용자의 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만 사용자가 많아질 수록 서버의 메모리를 많이 차지한다 

- 캐시
사용빈도가 높은 데이터를 고속으로 엑세스 할 수 있는 위치에 두는것 
데이터출력과 가까운 지점에 임시적으로 저장
데이터 재사용을 전제로 하고 실제 데이터 엑세스 부하를 줄일 수 있다 


***
### DB
#### n+1문제 
n+1문제는 데이터베이스와의 상호작용 시 쿼리를 1번 날렸지만 의도하지 않은 n번의 쿼리가 추가로 실행되는것을 의미합니다
조인이 설정된 엔티티를 조회할 경우 조회된 데이터갯수만큼 연관관계의 조회 쿼리가 추가로 발생해 데이터를 읽어오게 됩니다 
onetomany에서 one을 조회했더니 각 one의 many를 다시 조회하는 일이 발생하는 것을 예로 들 수 있급니다 

- lazy loading(지연로딩)
필요한 시점에 데이터를 로딩하는 방식으로 초기에는 데이터가 전부 로딩되지 않는다 
typeORM에서 엔티티 설정할때  칼럼의 속성을 Promise로 정의하면 실제로 해당 속성에 접근할때 쿼리가 실행됩니다 

- Eager Loading(즉시 로딩)
특정 엔티티 조회시 연관된 모든 데이터를 한꺼번에 로딩하는것으로 연관된 모든 엔티티를 가져온다는 장점이 있지만 불필요한 데이터 로딩과 메모리 사용량의 증가가 있어 성능에 영향이 갈 수 있습니다 
typeORM에서 relatuins을 통해 명시적으로 가져올 연관된 엔티티를 특정하면 됩니다  

***
#### nosql과 RDBMS
관게형 데이터베이스는 정해진 데이터 스키마에 따라 테이블에 저장되고 데이터는 관계를 통해 여러 테이블에 분산된다 
각 테이블은 사전에 정의된 스키마에 따라 구조화되고 스키마는 테이블의 열과 데이터 타입을 정의한다 
스키마를 준수하지 않은 레코드는 테이블에 추가 할 수 없다 
데이터의 무결성을 유지하기 위해 제약조건을 사용하며 중복을 피하기 위해 정규화를 사용한다 


nosql는 RDBMS의 반대로 고정된 스키마가 없고 다양한 데이터 모델을 지원한다 
레코드는 json과 비슷한 형식으로 저장되며 문서라고 부른다 
또란 nosql은 대용량의 데이터를 빠르게 읽고 쓸 수 있다 
RDBMS는 변경될 일이 없고 명확한 스키마가 중요한 경우 사용하고 nosql은 데이터의 구조가 변경되거나 확장 될 수 있는 경우, 읽기를 자주 하지만 데이터 변경은 자주 없는 경우 사용한다 

***
#### 정규화 
데이터베이스 설계시 데이터의 중복을 최소화하고 데이터의 무결성을 보장하기 위해 데이터를 구조화하는 과정

- 1형 정규형

테이블의 칼럼이 원자값을 가져야 한다 

- 2형 정규형
제 1 정규화를 진행한 테이블에 대한 부분함수종속을 완전함수종속을 만족하게 하는것
기본키가 부분집합의 키가 결정자가 되어서는 안된다 
부분함수 종속 -> 기본키중 특정 컬럼에만 종속되는것을 말함

- 3형 정규형
이행적 종속을 없애기 위해 테이블을 분리하는것
이행적종속(a -> b b->c 면 a ->c 가 성립)

- BCNF
모든 결정자가 후보키여야 한다 

- 4형 정규형
다치 종속을 제거한다 
다치종속은 같은 테이블내의 독립적인 두개 이상의 칼럼이 또 다른 컬럼에 종속되는것을 말한다

***
#### 역졍규화 
역규화란 정규화의 반대로 성능을 올리기 위해 데이터베이스의 구조를 의도적으로 데이터 중복을 허용 하는 것을 말합니다 

#### 트랜잭션과 ACID
트랜잭션은 데이터베이스에서 하나의 논리적 작업 단위를 나타내며, 여러 데이터베이스 연산을 하나의 작업 단위로 묶어주는 기능을 한다 
트랜잭션의 속성으로는 원자성,영속성, 일관성, 고립성이 있다 

- 원자성
트랜잭션은 논리적으로 쪼개질 수 없는 단위이기때문에 내부의 sql문은 전부 성공하거나 전부 실패해야 한다 

- 일관성
트랜잭션 이전과 이후는 일관된 상태를 유지해야 한다 

- 고립성
여러 트랜잭션이 실행되더라도 서로 영향을 주지않고 독립적으로 싱행되는것처럼 보여야 한다 

- 영속성
커밋된 트랜잭션의 결과는 데이터베이스에 영구적으로 저장되어야 한다 

***
#### 객체지향이란
객객체지향은 프로그램 설계방법론 중 하나로 프로그램을 객체라는 기본단위로 나누고 이 객체들이 서로 상호작용헤 프로그램을 구성하는 방법입니다 
기존의 방식이였던 절차적 방식은 명시적인 순서로 처리하는것이 중요했습니다 그 결과 복잡해지면 이해하기 힘든 스파게티 코드를 만들게 됩니다 
이한 문제점을 해결하기 위해 프로그램을 함수단위로 나눈 구조적 프로그래밍이 나오게 되지만 전역네임스페이스의 포화문제에 직면하게 되고 이를 해결하기 위해 나온것이 객체지항 프로그래밍입니다 

***
#### In-Memory Database
디스크가 아닌 주메모리에 모든 데이터를 저장하는 데이터베이스로 기존의 DB들보다 자료접근이 빠른게 장점입니다 
하지만 데이터가 휘발성이기 때문에 서버가 다운되거나 전원이 꺼지게 데이터가 날아간다는 단점이 있습니다 
그렇기 때문에 로그인 세션등 날아가도 괜찮은 임ㅅ기 데이터에 자주 쓰입니다 
또한 속도가 빠르기 떼문에 많은 데이터를 실시간으로 빠르게 처리해야하는 애플리케이션에서도 쓰입니다 

- redis를 쓴 이유
redis는 단순한 키값 구조가 아니라 여러 자료구조를 지원합니다 
string, hashset, sortedset를 사용했습니다 
또한 다른 인메모리디비인 멤케시드와 비교해보면 인메모리 디비지만 스냅샷을 통해 디스크에 백업을 할 수 있다는 장점이 있습니다 

레디스의 단점은 여러 자료구조를 지원하기 때문에 다른 인메모리디비보다 오버헤드가 있을 수 있고 설정이 복잡해 질 수 있습니다 
또한 단일 스레드 환경이기 때문에 동시성이나 다중처리가 필요한 작업에서는 한계를 보입니다 

***
#### xss
Cross-Site Scripting으로 공격자가 웹 페이지에 악성 스크립트를 삽입하여 다른 사용자가 해당 페이지를 방문할 때 악성 스크립트가 실행되도록 하는 공격 기법
사용자 입력을 검증하지 않는 다면 악의적으로 들어간 스크립트가 실행된다 

#### CSRF
공격자가 인증된 사용자가 모르게 특정 웹 애플리케이션에 요청을 보내게 하여 사용자의 권한으로 악의적인 작업을 수행하게 하는 공격 기법

#### SQL Injection
SQL Injection은 공격자가 애플리케이션의 SQL 쿼리에 악의적인 SQL 코드를 삽입하여 데이터베이스를 조작하거나 민감한 정보를 탈취하는 공격 기법

***
### 인프라 클라우드 
#### aws 인프라 구축 경험
깃액션을 통한 cd로 aws의ECR를 도커 이미지 저장소로 사용하고 가상서버인 EC2를 써 프로젝트를 실행했습니다 
데이터베이스로는 aws의 RDS를 사용해 mysql를 사용했고 프로젝트를 디벨롭 하면서 하나의 ec2에 부하가 너무 심하게 가해져 메인 서버를 여러 서버로 나누고 소켓서버와 메인서버로 들어오는 요청을 ALB를 사용해  경로기반 라우팅을 했습니다 
또한 하나의 메인서버 부하를 담당하기 때문에 부하테스트중 과부하가 걸리는것을 확인했고 (그라파나로 cpu 보니 남은 idle이 0.23) 이를 해결하기 위해 ECS를 사용해 인스턴스 수를 유동적으로 1개에서 3개까지 유동적으로 사용하고 elb를 사용해 트래픽을 분산했습니다 

#### 로드 밸런서
로드 밸런서는 네트워크 트래픽을 여러 서버로 분산시키는 장치 또는 서비스로 서버의 부하를 분산시켜 시스템의 성능과 가용성을 향상 시킵니다 
또한 서버중 하나가 장애가 발생해도 로드밸런서는 자동으로 다른 서버로의 트래픽을 전환해 서비스 중단을 방지합니다 

### 컨테이너 Devops
#### Docker란 무엇인가 
도커는 애플리케이션을 신속하게 구축 테스트 할 수 있는 플랫폼으로 컨테이너 가상화 기술을 사용해 애플리케이션과 종속성을 함께 패키징해 일관되게 실행되게 한다 
컨테이너 가상화는 다른 애플리케이션과 격리된 환경에서 실행할 수 있도록 하는 기술로 컨테이너는 os커널을 공유하지만 독립된 파일 시스템을 제공한다 

컨테이너 가상화를 사용하면 환경의 일관성을 유지해 어디에서나 동일환 환경을 사용할 수 있습니다 

***
#### CI/CD란 무엇인가 
ci는 지속적인 통합으로 빌드와 테스트를 자동화하는 과정이다 
ci는 변경사항을 자동으로 테스트해 애플리케이션에 문제가 없다는 것을 보장해준다 
코드를 정기적으로 빌드하고 테스트 하기 떄문에 충돌을 방지하고 모니터링 할 수 있다 

cd는 배포준비가 된 코드를 자동으로 배포하는 과정을 말한다 
성공적으로 통합된 코드가 레포지토리에 자동으로 병합되면 이 코드를 배포한다 

***
## AWS
#### aws ACM 
 SSL/TLS 인증서를 사용해 쉽게 관리 및 배포할 수 있도록 도와줍니다 

 #### AWS ECS
ecs는 aws에서 제공하는 컨테이너 오케스트레이션 서비스로 오토 스케일링을 통해 도커 컨테이너를 쉽게 실행하고 확장할 수 있습니다 
이 도커가 어느 그룹으로 들어갈지를 체크 

#### AWS ASG(Auto Scaling Group)
오토스케일링이란 클라우딩 컴퓨팅 환경엣거 수요에따라 리소르를 자동으로 조절하는 기능
ec2의 인스턴스의 수를 자동으로 조정해 가용성과 성능을 유지합니다 
기존을 세워놓고 cpu 사용량이 이 기준을 넘으면 인스턴스 수를 늘리고 이를 오토스케일링해  관리한다 

#### AWS ALB
어플리케이션 레벨 로드 밸런싱 서비스로 7게층에서 작동합니다 
http와 https 트래픽을 로드벨런싱을 하고 http로 오는 값을 https로 보내주고 , api는 api 서버로  ws요청은 소켓서버로 보냅니다 
