---
layout: post
read_time: true
show_date: true
title: "벡엔드 면접 대비 node 질문 정리"
date: 2024-06-26 15:01:20 -0600
description: "벡엔드 면접 대비 node 질문 정리 "
image: https://i.pinimg.com/564x/61/c3/b3/61c3b3ae85f68d1f742d58a5e8907815.jpg
tags: 
    - coding
    - cs
author: soi

toc: no # leave empty or erase for no TOC
---
#### Hoisting이란 무엇인지

호이스팅이란 자바스크립트에서 변수와 함수의 선언이 최상단으로 끌어올려지는것처럼 보이는 것으로 코드 실행 전 함수와 변수를 스캔하고 렉시컬 환경이라고 불리는 자바스크립트 데이터 구조내 환경에 추가됩니다 
이렇게 수집된 정보 덕분에 자바스크립트 엔진은 코드가 실행되기 전에 이미 해당 환경의 변수명을 알고 있게 됩니다 

- var, let
var로 선언된 변수는 스코프는 선언과 동시에 undefined로 초기화되지만 let은 호이스팅은 되지만 초기화는 선언문에 도달했을때 이루어집니다 그 전에 참조하게 되면 에러가 발생합니다 

#### TDZ란
![](https://velog.velcdn.com/images%2Fsoshin_dev%2Fpost%2F53592d46-e4c4-425a-8114-78f64ae040cd%2Fimage.png)

TDZ는 Temporal Dead Zone의 약자로 let과 const키워드로 선언된 변수가 초기화 되기 전까지 접근할 수 없는 영역을 의미 합니다
변수가 블록스코프안에서 선언되지만 초기화 되기 전까지 그 변수를 사용하는 것을 금지하는 것으로 선언전에 변수에 접근하는 것을 금지합니다 
const, let, class 등이 TDZ의 영향을 받고, var, function, import등이 영향을 받지 않습니다
 
 - var, let, const의 차이
 var는 함수스코프를 가지며 함수내에서 선언된 변수들이 함수 내부에서만 유효하다
함수 실행이 끝나면 변수가 소멸하지만 
const, let은 블록스코프를 가지며 블록({})내에서만 유효합니다

- 함수 선언식과 함수 표현식의 호이스팅 
함수 선언식은 호이스팅 되며 선언 이전에 호출해도 정상적으로 동작합니다 
함수표현식도 호이스팅이 되지만 선언 이전에 호출하면 에러가 나게 됩니다 

***
#### 실행컨텍스트란?
실행컨텍스트는 실행할 코드에 제공할 환경정보를 모아놓은 객체로 코드를 실행할때 환경정보를 모아 컨텍스트를 구성하고 이를 콜스택에 올렸다가 가장 위에 있는 컨텍스트와 관련있는 코드를 실행하는 식으로 순서를 보장합니다
실행컨텍스트 객체는 자바스크립트 엔진이 활용할 목적으로 생성할 뿐 확인할 수 없습니다 
실행컨텍스는에는 VariableEnvironment와 렉시컬 환경으로 구성되어있으며 VariableEnvironment에는 현재 컨텍스트 내부의 식별자들에 대한 정보와 외부환경 정보, 선언시점의 렉시컬 환경의 스냅샷이 담기고 렉시컬 환경은 기본적으로 동일하지만 변경사항이 실시간으로 반영됩니다
(이 렉시컬 환경 안의 Environment Record에 현재 스코프 내의 변수 함수선언이 담기게 되고 Outer Environment Reference에 외부 스코프에 대한 참조가 담기게 됩니다)

***
#### async/await 이란 무엇인지 설명
자바스크립트에서 비동기 코ㅗ드를 보다 직관적으로 동기식 코드처럼 작성할 수 있게 해주는 문법으로 es2017부터 도입됬습니다 
async를 사용해 해당 함수가 비동기 함수임을 나태내고 async함수 내부에서만 실행되는 await를 사용해 프로미스가 해결될때까지 함수의 실행을 일시정지하고 프로미스가 해결된다면 프로미스의 결과값을 반환하고 거부된다면 해당 거부 이유를 반환합니다 

***
#### 프로미스란
프로미스란 자바스크립트에서 비동기 작업읋 처리하기 위해 사용되는 객체로 미래에 완료될 작업을 나타냅니다 
프로미스는 세가지 상태를 가질 수 있으며 대기, 이행, 거부 상태를 가질 수 있습니다 

***
#### Arrow Function
Arrow Function은 ES6에 새로 도입된 함수 정의 방식입니다
기존의 함수 선언 방식보다 간결하고, this 바인딩 방식에서 중요한 차이점을 가지고 있습니다.

- this 바인딩
Arrow Function은 자신만의 this를 가지지 않고, 외부 스코프의 this를 그대로 사용하게 됩니다
이로인해 this 바인딩이 더 예측 가능해지고, bind 메서드를 사용할 필요가 줄어듭니다.
Arrow Function은 arguments 객체를 가지지 않습니다. 대신, 나머지 매개변수(rest parameters)를 사용해야 합니다.

arguments란 자바스크립트의 모든 함수내에서 사용할 수 있는 지역변수로 함수에 전달된 인수(arguments)들의 배열 비슷한 객체입니다 
arguments 객체를 사용하면 함수가 호출될 때 전달된 인수의 목록을 확인하거나 사용할 수 있습니다.

***
#### ‘==’와 ‘===’ 연산자의 차이
==와 ===는 자바스크립트에서 두 값을 비교하는 연산자이지만 둘은 차이가 있습니다
==는 동등연산자로 두값을 비교할때 타입변환을 수행한 후 비교하게 됩니다 둘의 타입이 다르더라고 자동으로 타입을 변환한 후 비교를 합니다

===는 일치연산자로 두 값을 비교할떄 타입변환을 수행하지 않고 엄격하게 비교를 합니다
비교시 두 값이 타입까지 같아야 true를 반환합니다

***
#### Express의 개념과 대안
- express란

express는 웹 애플리케이션 프레임워크 중 하나로 웹 서버 및 api를 쉽게 구축할 수 있습니다
express의 대안으로는 koa, Fastify, nest등이 있습니다

Koa는 express의 개발팀이 만든 프레임 워크로 async/await 패턴을 사용합니다
Fastify는 매우 빠른 프레임워크로 json을 자동으로 분석하기 때문에 속도가 빠릅니다
nest는 Angular에서 영감을 받은 프레임워크로 모듈기반 아키텍쳐와 의존성 주입을 지원합니다

왜 express를 선택했는지
express는 2021년 기준 점유율 89%으로 압도적이고 다른 3개에 비해 생태계가 잘 구성되어있어 정보를 얻기 쉬워 선택했습니다

***
#### Express와 nest.js의 차이
express에서 라이프사이클에 관한 부분을 개발자가 직접 설정을해줘야하지만 nest는 애플리케이션의 라이프 사이클을 자동으로 관리하는 기능을 제공한다
express는 async/await에서 발생하는 에러를 개별적으로 에러 처리 핸들러를 사용해야 하지만 nest에서는 예외 필터를 만ㄷ를어 중앙에서 자동으로 처리할 수 있습니다
또한 의존성 주입, 스웨거 자동작성등의 차이가 있다

***
#### 이벤트 루프
이벤트 루프는 자바스크립트 런타임이 비동기 작업을 처리하는 방식입니다. 자바스크립트는 싱글 스레드 언어이지만, 비동기 작업을 비동기적으로 처리하여 메인 스레드의 블로킹을 방지합니다. 

콜백큐는 비동기적으로 실행된 콜백함수가 보관되는 영역으로 콜백큐와 콜스택의 상태를 체크해 콜스택이 빈 상태가 되면 콜백큐에 있는 첫번째 콜백을 콜스택으로 이동시키게 됩니다
이벤트 루프는 콜스택이 비어있는지 확인하고 비어있지 않다면 기다리고 비어있다면 먼저 프로미스의 then, catch등이 대기하는 마이크로테스크 큐를 먼저 확인하고 대기중인 작업을 옮기고 마이크로테스크큐가 비어있다면 이벤트 루프는 테스크 큐를 확인해 대기중인 작업이 있다면 콜스택을오 옮겨 실행합니다 

***
#### single-threaded
Node.js는 자바스크립트 런타임으로, 싱글 스레드(Single-threaded) 기반으로 합니다.
Node.js가 한 번에 하나의 작업만 처리할 수 있는 단일 스레드를 사용한다는 것이지만 node는  이벤트 루프와 비동기 프로그래밍을 사용해 싱글 스레드의 단점인 낮은 처리량과 시간을 보완합니다
프로세스는 운영체제로부터 자원을 할당받은 작업의 단위로 메모리에 올라와 실행되고 있는 프로그램이고 스레드는 이런 프로세스로부터 할당받은 자원을 이용하는 실행흐름의 단위입니다 

***
#### Blocking VS Asynchronous
둘은 서로 비슷해보이지만 다른 개념으로 동기와 비동기는 요청한 작업의 완료 여부를 신경써서 작업을 순차적으로 실행할지 아닐지이고 Blocking은 현재 작업이 차단되냐 아니냐의 차이입니다 

- 동기와 비동기 

둘의 차이는 호출되는 함수의 리턴값 확인 유무로 Synchronous(동기)는  요청한 작업에대한 완료여부(리턴값)을 따져 처리하고 Asynchronous(비동기)는 요청한 작업의 완료여부를 확인하지 않는다 
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcEfFUW%2FbtrBgEBXt2b%2FseK9csNq9i683dapP5ktMK%2Fimg.png) 

- 블로킹과 논블로킹

블로킹과 논블로킹은 호출된 함수가 호출한 함수에게 제어권을 주느냐에 따라 구분합니다 
제어권은 프로그램 실행중에 함수의 코드나 프로세스의 실행흐륾을 제어할 수 있는 권리로 제어권을 주면 함수를 실행할 권리가 없어 실행이 멈추게 됩니다 

블로킹
![](https://velog.velcdn.com/images%2Fnittre%2Fpost%2F8cdc0a02-d469-47d5-96c8-f6aeef204eb7%2Fimage.png)

논블로킹
![](https://velog.velcdn.com/images%2Fnittre%2Fpost%2Fc839fc04-1788-4063-ab38-b0d4a312dbf4%2Fimage.png)

- 동기+ 블로킹


함수A는 함수B의 리턴값이 필요해(동기) 제어권을 b함수에 보내주고 실행이 완료되어 리턴값이 돌아올때 까지 기다린 후 다음 함수를 실행합니다

- 동기+논블로킹


a함수는 b함수를 호출하지만 제어권을 주지않고 자신은 계속 실행합니다 
하지만 리턴값이 필요하기 때문에 주기적으로 b함수에게 실행을 완료했는지 물어보게 됩니다 

- 비동기 + 논블로킹


비동기 방식이기 때문에 요청한 작업의 리턴값이 왔는지 여부를 신경쓰지 않고 계속 진행하고 제어권을 주지 않고 있다가 호출한 함수에 넘겨준 콜백함수를 실행합니다

- 비동기 + 블로킹


a함수는 b함수의 리턴값을 신경쓰지 않고 콜백함수를 사용하지만 b함수에게 제어권을 넘깁니다

제어권을 넘겨서 제어권을 다시 받을때까지(b함수가 끝나 다시 제어권을 받을때까지) 멈추게 된다 
다시 제어권이 오면 다시 함수를 실행합니다

***
#### 모든 요소에 인덱스를 걸지 않는 이유 
성능, 저장공간, 인덱스 유지 관리의 부담때문입니다  인덱스가 많아질수록 작업을 할때마다 인덱스를 갱신해야 하고 각 인덱스는 별도의 데이터구조로 저장되며 이는 추가적인 데이터 공간을 차지하게 됩니다 

***
#### 깊은 복사와 얉은복사의 차이 
- 깊은복사 
객체의 모든 프로퍼티의 값을 재귀적으로 복사합니다 복사된 객체는 원본객체와 달리 독립된 메모리 공간을 가집니다 
복된 객체와 원본객체는 서로 영향을 미치지 않습니다 
재귀함수를 사용하거나 JSON.stringify()를 사용해 구현할 수 있습니다

- 얉은 복사 
객체의 프로퍼티 값을 복사한다 복사된 객체는 원본 객체와 같은 참조를 공유하기 떄문에 복사된 객체의 프로퍼티를 변경하면 원본객체의 프로퍼티도 변경됩니다
Object.assign()과 스프레드 연산자를 사용해 얉은 복사를 할 수 있습니다 

***
#### JS의 passed by value 와 passed by reference 
- 값에 의한 전달
원시타입(number, string)등은 값에 의한 전달방식으로 동작합니다 
원시타입은 값이 한번 정해지면 바뀌지 않기 때문에 값을 변경하려면 새로운 값을 재할당해야한다 
다른 변수에 복사할떄 pass by value방식을 사용해 변수에 저장된 값이 복사되어 전달됩니다 

- 참조에 의한 전달
객체타입은 원시타입과 반대로 값을 바꿀 수 있어 메모리의 크기를 사전에 저장할 수 없어 객체타입과 다르게 값을 저장하지 않고 메모리의 주소를 저장하게 됩니다 
따라서 다른 변수에 복사할때 값이 아니라 저장하고 있던 메모리 주소를 전달한다 

***
#### JWT
JWT는 안중벋운 사용자에게 토큰을 발급해주고 서버에 요청을 할떄 http 헤더에 토큰을 보내 인증받은 사용자 인지 확인합니다 서버에서는 들어온 토큰을 검증할때 헤더에서 jwt를 추출하고 시그니쳐와 유효성을 검증합니다 
또한 jwt는 만료기간이 있으며 만료된 토큰을 재발급하기 위해 서버의 엑세스 토큰과 함께 만료기간이 더 긴 리프래시 토큰을 발급해  엑세스 토큰이 만료되었을때  리프래시 토큰을 사용해 새 엑세스 토큰을 발급합니다

***
#### mvc 패턴
MVC 패턴은 소프트웨어 디자인 패턴 중 하나로, 애플리케이션을 세 가지로 분류해 개발과 유지보수를 쉽게 하기 위해 사용합니다 
모델은 애플리케이션의 핵심 데이터와 비즈니스 로직을 담당합하고 뷰는 사용자의 인터페이스를 담당하고 사용자의 입력을 받아 컨트롤러로 전달합니다 
컨트롤러는 사용자의 입력을 받아 모델이나 뷰를 업데이트 하고 모델과 뷰 사이 상호작용을 관리합니다 
컨트롤러를 3개로 분리해 컨트롤러 레포지토리 서비스로 분리 할 수도 있습니다