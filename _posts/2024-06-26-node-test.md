---
layout: post
read_time: true
show_date: true
title: "벡엔드 면접 대비 node 질문 정리"
date: 2024-06-26 15:01:20 -0600
description: "벡엔드 면접 대비 node 질문 정리 "
image: https://i.pinimg.com/564x/61/c3/b3/61c3b3ae85f68d1f742d58a5e8907815.jpg
tags: 
    - coding
    - cs
author: soi

toc: no # leave empty or erase for no TOC
---
#### Hoisting이란 무엇인지

호이스팅이란 자바스크립트에서 변수와 함수의 선언이 최상단으로 끌어올려지는것처럼 보이는 것으로 코드 실행 전 함수와 변수를 스캔하고 렉시컬 환경이라고 불리는 자바스크립트 데이터 구조내 환경에 추가됩니다 
이렇게 수집된 정보 덕분에 자바스크립트 엔진은 코드가 실행되기 전에 이미 해당 환경의 변수명을 알고 있게 됩니다 

- var, let
var로 선언된 변수는 스코프는 선언과 동시에 undefined로 초기화되지만 let은 호이스팅은 되지만 초기화는 선언문에 도달했을때 이루어집니다 그 전에 참조하게 되면 에러가 발생합니다 

#### TDZ란
![](https://velog.velcdn.com/images%2Fsoshin_dev%2Fpost%2F53592d46-e4c4-425a-8114-78f64ae040cd%2Fimage.png)

TDZ는 Temporal Dead Zone의 약자로 let과 const키워드로 선언된 변수가 초기화 되기 전까지 접근할 수 없는 영역을 의미 합니다
변수가 블록스코프안에서 선언되지만 초기화 되기 전까지 그 변수를 사용하는 것을 금지하는 것으로 선언전에 변수에 접근하는 것을 금지합니다 
const, let, class 등이 TDZ의 영향을 받고, var, function, import등이 영향을 받지 않습니다
 
 - var, let, const의 차이
 var는 함수스코프를 가지며 함수내에서 선언된 변수들이 함수 내부에서만 유효하다
함수 실행이 끝나면 변수가 소멸하지만 
const, let은 블록스코프를 가지며 블록({})내에서만 유효합니다

- 함수 선언식과 함수 표현식의 호이스팅 
함수 선언식은 호이스팅 되며 선언 이전에 호출해도 정상적으로 동작합니다 
함수표현식도 호이스팅이 되지만 선언 이전에 호출하면 에러가 나게 됩니다 

***
#### 실행컨텍스트란?
실행컨텍스트는 실행할 코드에 제공할 환경정보를 모아놓은 객체로 코드를 실행할때 환경정보를 모아 컨텍스트를 구성하고 이를 콜스택에 올렸다가 가장 위에 있는 컨텍스트와 관련있는 코드를 실행하는 식으로 순서를 보장합니다
실행컨텍스트 객체는 자바스크립트 엔진이 활용할 목적으로 생성할 뿐 확인할 수 없습니다 
실행컨텍스는에는 VariableEnvironment와 렉시컬 환경으로 구성되어있으며 VariableEnvironment에는 현재 컨텍스트 내부의 식별자들에 대한 정보와 외부환경 정보, 선언시점의 렉시컬 환경의 스냅샷이 담기고 렉시컬 환경은 기본적으로 동일하지만 변경사항이 실시간으로 반영됩니다
(이 렉시컬 환경 안의 Environment Record에 현재 스코프 내의 변수 함수선언이 담기게 되고 Outer Environment Reference에 외부 스코프에 대한 참조가 담기게 됩니다)

***
#### async/await 이란 무엇인지 설명
자바스크립트에서 비동기 코ㅗ드를 보다 직관적으로 동기식 코드처럼 작성할 수 있게 해주는 문법으로 es2017부터 도입됬습니다 
async를 사용해 해당 함수가 비동기 함수임을 나태내고 async함수 내부에서만 실행되는 await를 사용해 프로미스가 해결될때까지 함수의 실행을 일시정지하고 프로미스가 해결된다면 프로미스의 결과값을 반환하고 거부된다면 해당 거부 이유를 반환합니다 

***
#### 프로미스란
프로미스란 자바스크립트에서 비동기 작업읋 처리하기 위해 사용되는 객체로 미래에 완료될 작업을 나타냅니다 
프로미스는 세가지 상태를 가질 수 있으며 대기, 이행, 거부 상태를 가질 수 있습니다 

***
#### Arrow Function
Arrow Function은 ES6에 새로 도입된 함수 정의 방식입니다
기존의 함수 선언 방식보다 간결하고, this 바인딩 방식에서 중요한 차이점을 가지고 있습니다.

- this 바인딩
Arrow Function은 자신만의 this를 가지지 않고, 외부 스코프의 this를 그대로 사용하게 됩니다
이로인해 this 바인딩이 더 예측 가능해지고, bind 메서드를 사용할 필요가 줄어듭니다.
Arrow Function은 arguments 객체를 가지지 않습니다. 대신, 나머지 매개변수(rest parameters)를 사용해야 합니다.

arguments란 자바스크립트의 모든 함수내에서 사용할 수 있는 지역변수로 함수에 전달된 인수(arguments)들의 배열 비슷한 객체입니다 
arguments 객체를 사용하면 함수가 호출될 때 전달된 인수의 목록을 확인하거나 사용할 수 있습니다.

***
#### ‘==’와 ‘===’ 연산자의 차이
==와 ===는 자바스크립트에서 두 값을 비교하는 연산자이지만 둘은 차이가 있습니다
==는 동등연산자로 두값을 비교할때 타입변환을 수행한 후 비교하게 됩니다 둘의 타입이 다르더라고 자동으로 타입을 변환한 후 비교를 합니다

===는 일치연산자로 두 값을 비교할떄 타입변환을 수행하지 않고 엄격하게 비교를 합니다
비교시 두 값이 타입까지 같아야 true를 반환합니다

***
#### Express의 개념과 대안
- express란

express는 웹 애플리케이션 프레임워크 중 하나로 웹 서버 및 api를 쉽게 구축할 수 있습니다
express의 대안으로는 koa, Fastify, nest등이 있습니다

Koa는 express의 개발팀이 만든 프레임 워크로 async/await 패턴을 사용합니다
Fastify는 매우 빠른 프레임워크로 json을 자동으로 분석하기 때문에 속도가 빠릅니다
nest는 Angular에서 영감을 받은 프레임워크로 모듈기반 아키텍쳐와 의존성 주입을 지원합니다

왜 express를 선택했는지
express는 2021년 기준 점유율 89%으로 압도적이고 다른 3개에 비해 생태계가 잘 구성되어있어 정보를 얻기 쉬워 선택했습니다

***
#### Express와 nest.js의 차이
express에서 라이프사이클에 관한 부분을 개발자가 직접 설정을해줘야하지만 nest는 애플리케이션의 라이프 사이클을 자동으로 관리하는 기능을 제공한다
express는 async/await에서 발생하는 에러를 개별적으로 에러 처리 핸들러를 사용해야 하지만 nest에서는 예외 필터를 만ㄷ를어 중앙에서 자동으로 처리할 수 있습니다
또한 의존성 주입, 스웨거 자동작성등의 차이가 있다

***
#### 이벤트 루프
이벤트 루프는 자바스크립트 런타임이 비동기 작업을 처리하는 방식입니다. 자바스크립트는 싱글 스레드 언어이지만, 비동기 작업을 비동기적으로 처리하여 메인 스레드의 블로킹을 방지합니다. 

콜백큐는 비동기적으로 실행된 콜백함수가 보관되는 영역으로 콜백큐와 콜스택의 상태를 체크해 콜스택이 빈 상태가 되면 콜백큐에 있는 첫번째 콜백을 콜스택으로 이동시키게 됩니다
이벤트 루프는 콜스택이 비어있는지 확인하고 비어있지 않다면 기다리고 비어있다면 먼저 프로미스의 then, catch등이 대기하는 마이크로테스크 큐를 먼저 확인하고 대기중인 작업을 옮기고 마이크로테스크큐가 비어있다면 이벤트 루프는 테스크 큐를 확인해 대기중인 작업이 있다면 콜스택을오 옮겨 실행합니다 

***
#### single-threaded
Node.js는 자바스크립트 런타임으로, 싱글 스레드(Single-threaded) 기반으로 합니다.
Node.js가 한 번에 하나의 작업만 처리할 수 있는 단일 스레드를 사용한다는 것이지만 node는  이벤트 루프와 비동기 프로그래밍을 사용해 싱글 스레드의 단점인 낮은 처리량과 시간을 보완합니다
프로세스는 운영체제로부터 자원을 할당받은 작업의 단위로 메모리에 올라와 실행되고 있는 프로그램이고 스레드는 이런 프로세스로부터 할당받은 자원을 이용하는 실행흐름의 단위입니다 

***
#### Blocking VS Asynchronous
둘은 서로 비슷해보이지만 다른 개념으로 동기와 비동기는 요청한 작업의 완료 여부를 신경써서 작업을 순차적으로 실행할지 아닐지이고 Blocking은 현재 작업이 차단되냐 아니냐의 차이입니다 

- 동기와 비동기 

둘의 차이는 호출되는 함수의 리턴값 확인 유무로 Synchronous(동기)는  요청한 작업에대한 완료여부(리턴값)을 따져 처리하고 Asynchronous(비동기)는 요청한 작업의 완료여부를 확인하지 않는다 
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcEfFUW%2FbtrBgEBXt2b%2FseK9csNq9i683dapP5ktMK%2Fimg.png) 

- 블로킹과 논블로킹

블로킹과 논블로킹은 호출된 함수가 호출한 함수에게 제어권을 주느냐에 따라 구분합니다 
제어권은 프로그램 실행중에 함수의 코드나 프로세스의 실행흐륾을 제어할 수 있는 권리로 제어권을 주면 함수를 실행할 권리가 없어 실행이 멈추게 됩니다 

블로킹
![](https://velog.velcdn.com/images%2Fnittre%2Fpost%2F8cdc0a02-d469-47d5-96c8-f6aeef204eb7%2Fimage.png)

논블로킹
![](https://velog.velcdn.com/images%2Fnittre%2Fpost%2Fc839fc04-1788-4063-ab38-b0d4a312dbf4%2Fimage.png)

- 동기+ 블로킹
함수A는 함수B의 리턴값이 필요해(동기) 제어권을 b함수에 보내주고 실행이 완료되어 리턴값이 돌아올때 까지 기다린 후 다음 함수를 실행합니다

- 동기+논블로킹
a함수는 b함수를 호출하지만 제어권을 주지않고 자신은 계속 실행한다 하지만 리턴값이 필요하기 때문에 주기적으로 b함수에게 실행을 완료했는지 물어보게 됩니다 

- 비동기 + 논블로킹
비동기 방식이기 때문에 요청한 작업의 리턴값이 왔는지 여부를 신경쓰지 않고 계속 진행하고 제어권을 주지 않고 있다가 호출한 함수에 넘겨준 콜백함수를 실행합니다

- 비동기 + 블로킹
a함수는 b함수의 리턴값을 신경쓰지 않고 콜백함수를 사용하지만 b함수에게 제어권을 넘깁니다
제어권을 넘겨서 제어권을 다시 받을때까지(b함수가 끝나 다시 제어권을 받을때까지) 멈추게 된다 
다시 제어권이 오면 다시 함수를 실행합니다

***
#### 모든 요소에 인덱스를 걸지 않는 이유 
성능, 저장공간, 인덱스 유지 관리의 부담때문입니다  인덱스가 많아질수록 작업을 할때마다 인덱스를 갱신해야 하고 각 인덱스는 별도의 데이터구조로 저장되며 이는 추가적인 데이터 공간을 차지하게 됩니다 

***
####