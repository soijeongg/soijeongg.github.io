---
layout: post
read_time: true
show_date: true
title: "[항해 99] 주특기 1차 과제"
date: 2024-02-07 15:00:20 -0600
description: "[항해 99] 주특기 1차 과제"
image: https://i.pinimg.com/736x/33/62/6a/33626ae9adfa3f30190d8734032315b2.jpg
tags: 
    - coding
    - diary
    - hh99
author: soi

toc: no # leave empty or erase for no TOC
---

![](https://velog.velcdn.com/images/soijeongg/post/6b3bb56e-44fa-4d57-8664-b26590b396a7/image.jpeg)
코어자바스크립트 01.데이터 타입 부분

### 데이터 타입 심화
자바스크립트에서 값의 타입은 기본형과 참조형으로 구분
![](https://velog.velcdn.com/images/soijeongg/post/555c68de-c81e-46c7-a81f-4fbf888d041d/image.png)
- 기본형
Number, String, Boolean, null, undefined, symbol
- 참조형
객체
(array, function, date, regexp(정규표현식), map, set)

기본형은 값이 담긴 주소값을 복제 하고 불변성을 띈다(값이 아니라 메모리가 불변) 
참조형은 값이 담긴 주소값들로 이루어진 묶음을 가르키는 주소값 복제하고 가변성

### 메모리와 데이터
- 비트 
컴퓨터가 이해할 수 있는 가장 작은단위 0과 1로 이루어짐 
- 바이트 
8개의 비트-> 1바이트
메모리는 바잍 단위로 구성 모든 데이터는 바이트 단위인 식별자의 메모리 주소값을 통해 서로 구분

- java, C와는 다른 자바스크립트 메모리 관리 방법
메모리 할당: 자바스크립트는 생성된 객체에 필요한 메모리를 할당
메모리 사용: 메모리를 읽고 쓰는 작업은 변수에 읽거나 변수에 쓰는 작업을 의미
메모리 해제: 할당됐던 메모리 해제(가비지 콜렉터)
- 자바스크립트의 메모리 관리 방법
Javascript
let a = 8(8바이트)
let a = "a"(2바이트 이상, 길이에 따라 달라짐)
let a = True(1바이트)


Java:
byte a = 8; (1바이트)
short a = 8; (2바이트)
int a = 8; (4바이트)
long a = 8; (8바이트)

C 언어:
char a = 8; (1바이트)
short a = 8; (2바이트)
int a = 8; (4바이트)
long a = 8; (8바이트)
데이터 타입에 따라 할당되는 메모리가 다르다
자바나 c언어는 오래된 언어이기 때문에 당시는 메모리가 지금처럼 많지 않음 그래서 메모리의 크기까지 관여

- 식별자와 변수 
let a =1
 변수명(식별자)=변수(데이터)

### 변수선언과 데이터 할당
코어자바스크립트 발췌(나는 책 있어서 책 보고 하기로)
1. 데이터 선언
var a;
변할 수 있는 데이터를 만든다 이 데이터의 식별자는 a라고 한다 
변수==변경이 가능한 데이터 담기는 공간
이렇게 되면 어떤 주소값에 

|주소|1001|1002|1003|
|---|:---:|:---:|:---:|
|데이터||이름 :a
|내용 4||값:|

일단 명령을 받고 비어있는 공간을 확보(여기에서는 임의로 1003으로)
이곳의 이름을 a라고 지정한다
이후 사용자가 a에 접근 할려고 하면 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터 반환
(그니까 1003번의 이름을 a로 지정하고 메모리의 값을 찾는다)

2. 데이터 할당
자바스크립트에서는 데이터 할당을 하는 방법은 2가지가 있다 
1)
```javascript
var a;
a= "abc"
```
이렇게 선언과 할당을 나눠서 할 수도 있고 
2)
```javascript
var a="abc"
```
한꺼번에 할수도 있다

 생각해보면 메모리에 비어있는 공간을 확보하고 이름을 a로 지정한 다음 거기에 값을 저장하면 될거 같다
 **하지만 해당 위치에 문자열 'abc'를 직접 저장하지 않는다!**
 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열을 저장하고 **그 주소를 다시 변수에 저장하는 방식**
 
 |주소|1001|1002|1003|
|---|:---:|:---:|:---:|
|데이터||이름 :a|
|||값:2002| |
|주소|2001|2002|2003|
|||'abc'|

값을 따로 저장할 빈공간을 확보 한다  그 후 거기에 문자열을 따로 저장
변수영역에서 a라는 변수명(식별자)를 검색하고 앞서 저장한 문자열의 주소를 이 a라는 공간에 대입

- 왜 변수영역에 값을 직접 저장하지 않고 한단계를 굳이 더 거치냐면
**데이터 변화를 자유롭게 할 수 있게함과 동시에 메모리를 좀 더 효율적으로 관리하기 위해**
자바스크립트는 문자열은 특별히 정해진 규격이 없다 
만약 미리 확보한 공간내에서만 할 수 있다면 변환한 데이터를 다시 저장하기 위해서는 확보된 공간을 변환된 데이터의 크기에 맞게 늘리는 작업이 먼저 있어야 함
이게 마지막에 있으면 괜찮은데 중간에 있는걸 늘려야 한다면 다른 것을 전부 오른쪽으로 밀어야 한다 
(해당 공간보다 뒤에 저장된 데이터를 전부 뒤로 옮기고 이동시킨 주소를 각 식별자에 다시 연결하는 작업을 해야 한다-> **연산이 많아진다**)
문자열끝에 def를 추가하려고 하면 앞서 abc가 저장된 공가에 다시 할당하는 대신 새로운 문자열인 abcdef를 만들어 다른 비어있는 메모리에 저장한다
**기존 문자열에 어떤 변환을 가하든 상관없이 무조건 새로 만든다**

### 기본형 데이터와 참조형 데이터
1. 변수와 상수의 차이
	1. 변수:바꿀 수 있다
    2. 상수: 바꿀 수 없다

2. 불변하다 vs 불변하지 않다
    1. 불변하다 : 데이터 영역 메모리를 변경할 수 없음
    2. 불변하지 않다 : 데이터 영역 메모리를 변경할 수 있음
    
**이 둘은 같은 개념이 아니다**
변수와 상수를 구분짓는것은 변수영역의 메모리로 데이터 할당이 이루어진 변수공간에 다른 데이터를 재할당 할 수 있는지(**메모리와는 다름**)
```javascript
// a라는 변수가 abc에서 abcdef가 되는 과정을 통해 불변성을 유추해봅시다!

// 'abc'라는 값이 데이터영역의 @5002라는 주소에 들어갔다고 가정할게요.
var a = 'abc';

// 'def'라는 값이 @5002라는 주소에 추가되는 것이 아니죠!
// @5003에 별도로 'abcdef'라는 값이 생기고 a라는 변수는 @5002 -> @5003
// 즉, "변수 a는 불변하다." 라고 할 수 있습니다.
// 이 때, @5002는 더 이상 사용되지 않기 때문에 가비지컬렉터의 수거 대상이 됩니다.
a = a + 'def';
//abc와 abcdef는 완전히 다른 별개의 데이터
```
```javascript
var b=5
var c=5;
```
변수 b에 숫자 5를 할당(데이터 영역에서 5를 찾고 없으면 데이터 공간을 하나만들어 저장)
그다음 c에서 5을 다시 할당, 이때 이미 만들어놓은 값이 있으니 그 주소 재활용

한번 만든 값은 데이터에 재할당 되더라도 변경되지 않고 새로 만들어진다
가비지 컬렉터에 삭제되지 않는한 영원히 변하지 않는다 

- 가변값
참조형인 객체(array, function, date, regexp(정규표현식), map, set)는 가변이다 

```javascript
var obj1 = {
  a:1,
  b:'bbb'
};
```
1. 우선 빈공간을 먼저 확보하고 그곳의 이름을 obj1로 지정
2. 임의의 데이터 공간(501)에 데이터를 저장할려고 보니 여러 값인 객체임
3. 저장하기 위해 임의의 별도의 변수 영역을 마련-> 그 영역의 주소를 원래 저장할려고 했던 데이터 공간에 저장
4. 데이터 영역에서 숫자 1 검색 후 없으니 임의의 공간에 저장 문자bbb또한 같음
5. 이때 임의의 공간의 값 주소 저장하는것은 다른 것 저장하는 것과 같음

|주소|1001|1002|1003|1004|
|---|:---:|:---:|:---:|:--:|
|데이터||이름: obj1||
|||값:0501||
|주소|5001|5002|5003|5004
|데이터|07103 ~?||1|'bbb'|

임의의 공간

|주소|7103|7104|7015|
|---|:---|:---:|---:|
||이름:a|이름:b||
||값:0503|값:0504

기본형과의 차이점은 객체의 변수(프로퍼티)영역이 따로 존재한다는 점
허지만 객체가 별도로 할애한 영역은 변수영역일 뿐 데이터 영역은 기존의 영역을 그대로 활용
데이터영역은 모두 불변값이지만 변수에는 다른 값을 얼마든지 대입할 수 있기 때문에 데이터는 불변하지 않는다고 하는것
내부의 프로퍼티의 값이 바뀌더라도 별도의 프로퍼티에 할당한 값 부분이 바뀌는거지 기존의 메모리 영역은 바뀌지 않는다 

**참조형 데이터가 ‘가변값’이라고 할 때의 ‘가변’은 참조형 데이터 자체를 변경할 경우가 아니라, 그 내부의 프로퍼티를 변경할 때 성립**

### 변수복사 비교
기본형 데이터와 참조형 데이터의 차이를 확인
```javascript
var a=10;
var b =a;

var obj1 = {c:10,d:'ddd'}
var obj2 = obj1;
```
먼저 생각해보기
1. a라는 값을 검색하고 없으면 새로운 메모리 주소에 a라는 이름을 지정

2. 10이라는 값을 검색하고 없으면 다른 주소에 데이터로 저장한다

3. 변수영역 b를 새로운 공간에 저장하고 값을 a와 같은 값으로 만든다

4. obj를 저장할려고 보니 값이 객체인 프로퍼티-> 그래서 새로운 별도의 공간을할당한다

5. 그 영역의 주소를 원래 데이터공간에 저장한다

6. 별도의 데이터 공간에 이름이 c, b 를 입력한 다음 각각 원래 공간에서 값인 10과 , ddd를 검색하고 없으면 새로운 공간에 만든다

7. 그 영역의 주소를 원래 메모리에 저장한다(한번 거침)

8. 값을 기존의 메모리에 저장한 영역의 주소를 식별자가 obj1이라는 영역의 값으로 저장한다

**9. obj2라는 값이 obj1을 복사하고 있기에 obj2를 검색하고 없으면 빈공간을 확보해 식별자를 obj2로 저장한다
그후 값인 식별자 obj1값을 검색해 그 값인 주소값을 obj2가 저장된 주소값에 저장한다**

이렇게 되면 b와 a가 모두 같은 주소값을 가르키게 되고 obj1과 obj2가 같은 주소값을 가르키게 된다
```javascript
b=15;
obj2.c=20;
```
첫번째 
이렇게 되면 메모리에 15라는 데이터를 찾고 없으면 빈공간을 찾아 15를 입력한 다음 원래 b의 주소값을 15의 주소값으로 바꾼다 

두번째 
20이라는 데이터를 검색해 없으면 빈공간을 확보해 저장하고 별도의 프로퍼티를 저장하는 공간에 있던 식별자가 c인 영역의 값을 20이 입력되어있는 주소값으로 바뀐다
하지만 기존의 공간에서 프로퍼티의 값과 연결(?)하는 부분의 주소는 바뀌지 않고 원래 있던 obj1 과 obj2또한 둘 다 연결(?)하는 부분의 주소를 값으로 가지고 있는것 또한 바뀌지 않는다

이때 문제점은 우리는 obj2만 바꿨는데 동시에 참조하고 있던 영역의 값부분이 가르키는 영역의 값이 바뀌면서 obj2뿐만이 아니라 obj1의 값또한 바뀐다
(그래서 이거 .slice()해서 복사한다고 하는거구나)

### 불변객체
참조형 데이터의 가변은 데이터 자체가 아닌 내부의 프로퍼티를 변경할때만 성립
데이터 자체를 변경할려고 하면 변경되지 않는다 
내부의 프로퍼티를 바꿔야 할때마다 매번 새로운 객체를 만들어 재할당을 하기로 하면 불변성을 확보 가능

```javascript
// user 객체를 생성
var user = {
	name: 'soi',
	gender: 'female',
};

// 이름을 변경하는 함수, 'changeName'을 정의
// 입력값 : 변경대상 user 객체, 변경하고자 하는 이름
// 출력값 : 새로운 user 객체
// 특징 : 객체의 프로퍼티(속성)에 접근해서 이름을 변경했네요! -> 가변
var changeName = function (user, newName) {
	var newUser = user;
	newUser.name = newName;
	return newUser;
};

// 변경한 user정보를 user2 변수에 할당하겠습니다.
// 가변이기 때문에 user1도 영향을 받게 될거에요.
var user2 = changeName(user, 'twojang');

// 결국 아래 로직은 skip하게 될겁니다.
if (user !== user2) {
	console.log('유저 정보가 변경되었습니다.');
}

console.log(user.name, user2.name); // twojang twojang
console.log(user === user2); // true
```
이건 가변성으로 인한 문제점을 알려주는 것

먼저 생성된 객체가 앞서 나온것과 같은 방법으로 이름따로 값따로 그 값과 연결된 프로퍼티 따로 값 각각의 영역 따로 저장이 됨
그 후 이름을 변경하는 함수를 만들어 newuser라는 객체로 user를 복사하고 (이때 같은 영역을 참조하게 된다 )
그 uewname의 name이라는 프로퍼티의 값을 newname으로 바꾼다 
(근데 이렇게 되면 별도의 영역에 저장됨 프로퍼티의 값이 바뀌게 되면서 전부 바뀌게 된다)

이걸 쉽게는 이렇게 바꿀 수 있다
```javascript
// user 객체를 생성
var user = {
	name: 'wonjang',
	gender: 'male',
};

// 이름을 변경하는 함수 정의
// 입력값 : 변경대상 user 객체, 변경하고자 하는 이름
// 출력값 : 새로운 user 객체
// 특징 : 객체의 프로퍼티에 접근하는 것이 아니라, 아에 새로운 객체를 반환 -> 불변
var changeName = function (user, newName) {
	return {
		name: newName,
		gender: user.gender,
	};
};

// 변경한 user정보를 user2 변수에 할당하겠습니다.
// 불변이기 때문에 user1은 영향이 없어요!
var user2 = changeName(user, 'twojang');

// 결국 아래 로직이 수행되겠네요.
if (user !== user2) {
	console.log('유저 정보가 변경되었습니다.');
}

console.log(user.name, user2.name); // wonjang twojang
console.log(user === user2); // false 👍
```
return {
		name: newName,
		gender: user.gender,
	};이라는 익명의객체 반환

이 익명의 객체는 이름을 newname으로 하고 gender를 가지고 새로운 객체를 만든것이라 아예 새로운 객체를 만든거라 불변이다 
새로운 객체를 만들면서 바꿀필요가 없는 기존의 객체는 하드코딩으로 전부 입력 
객체에 정보가 많다면 이런걸 모두 입력해야 한다
(하지만 이것도 name만 바꾼거라 gender가 바뀌면 값이 둘 다 바뀐다)

이런 방식보다 객체에 상관없이 모든 프로퍼티를 복사하는 함수를 만드는 편이 좋음
```javascript
//이런 패턴은 어떨까요?
var copyObject = function (target) {
	var result = {};

	// for ~ in 구문을 이용하여, 객체의 모든 프로퍼티에 접근할 수 있습니다.
	// 하드코딩을 하지 않아도 괜찮아요.
  //prop로 가져와서 result라는 이름에 복사한다
	// 이 copyObject로 복사를 한 다음, 복사를 완료한 객체의 프로퍼티를 변경하면
	// 되겠죠!?
	for (var prop in target) {
		result[prop] = target[prop];
	}
	return result;
}
```
객체의 모든 프로퍼티에 접근해 복사해서 새로운 배열을 만든다
이렇게 되면 프로퍼티의 값이 같더라도 다른 배열이기때문에 그 프로퍼티와 연결(?)되어 있는 기존의 데이터메모리의 주소가 다르다 
그래서 바뀌지 않기 떄문에 서로 간섭을 안한다
이런 방법은 **얕은복사**라고 부른다

```javascript
//위 패턴을 우리 예제에 적용해봅시다.
var user = {
	name: 'wonjang',
	gender: 'male',
};
//복사해서 사용
var user2 = copyObject(user);
user2.name = 'twojang';

if (user !== user2) {
	console.log('유저 정보가 변경되었습니다.');
}

console.log(user.name, user2.name);
console.log(user === user2);
```
이제부터 협업하는 모든 개발자들이 객체를 복사하고 수정할때는 모두 이 함수를 사용하기로 합의하기로 하고 이 규칙을 아무도 깨지않고 잘 지킨다면 불변객체라고 할 수 있다

하지만 그런거 보다는 시스템 적으로 막는것이 더 안전
- 얕은 복사와 깊은 복사

1. 얕은 복사 : 바로 아래 단계의 값만 복사(위의 예제)
문제점 : 중첩된 객체의 경우 참조형 데이터가 저장된 프로퍼티를 복사할 때, 주소값만 복사
2. 깊은 복사 : 내부의 모든 값들을 하나하나 다 찾아서 모두 복사하는 방법

얕은 복사만 수행하면 중첩된 객체에서 참조형 데이터가 복사시 주소값을 복사하기 때문에 중첩된 데이터의 값을 바꾸면 전부 다 바뀌어 버린다 

* 왜 이러한 일이 이러날까?
객체를 복사할때 객체의 프로퍼티들은 새로운 객체에 복사되지만 중첩된객체는 메모리가 복사되는데 이는 자바스크립트의 특성으로 중첩된 객체를 완전히 복사한다면 메모리 사용량이불필요하게 증가하기 때문에 주소만 복사한다

이런 현상이 발생하지 않도록 중첩된 객체도 불변객체로 만들필요가 있다 
```javascript
var user = {
	name: 'wonjang',
	urls: {
		portfolio: 'http://github.com/abc',
		blog: 'http://blog.com',
		facebook: 'http://facebook.com/abc',
	}
};

// 1차 copy
var user2 = copyObject(user);

// 2차 copy -> 이렇게까지 해줘야만 해요..!!
user2.urls = copyObject(user.urls);

user.urls.portfolio = 'http://portfolio.com';
console.log(user.urls.portfolio === user2.urls.portfolio);

user2.urls.blog = '';
console.log(user.urls.blog === user2.urls.blog);
```
객체의 프로퍼티 중, 기본형 데이터는 그대로 복사 + 참조형 데이터는 다시 그 내부의 프로퍼티를 복사 ⇒ 재귀적 수행!
```javascript
var copyObjectDeep = function(target) {
	var result = {};
  //null일때도 object를 반환하기 때문에 !==null
	if (typeof target === 'object' && target !== null) {
		for (var prop in target) {
			result[prop] = copyObjectDeep(target[prop]);
		}
	} else {
		result = target;
	}
	return result;
}
```
재귀인 이유는 참조형인 이유 다시 내부의 프로퍼티를 복사해야 하기 때문

- 객체를 json으로 복사
객체를 json문법으로 문자열로 전환했다감(JSON.stringify() 함수를 사용) 다시 json객체로 바꾸는것
다만 메서드나 숨겨진 프로퍼티인 _proto_나 getter setter등 제이슨으로 변경 할 수 없는것은 무시한다
httpRequest로 받은 데이터를 저장한 객체를 복사할때 활용하기 좋음

### undefined와 null
둘다 없음을 나타낸다는 점에서는 같지만 두 값의 의미는 같은것 같지만 미세하게 다르고 사용하는 목적 또한 다르다

- undefined
정의되지 않음
사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을때 자바스크립트 엔진이 자동으로 부여하는 경우도 존재
값이 있어야 할거 같은데 없는 경우 

비어있는 요소와 undefined를 할당한 요소는 출력결과도 다르고 바어있는 요소는 순회와 관련된 많은 배열 메소드들의 순회대상에서 제외됨

- null
없다를 명시적으로 표현할때 사용 
애초에 이런용도로 쓰라고 만든 값 
typeof null이 object라는 것은자바스크립트 자체 버그 => ==로 비교할경우 둘이 같다고 나오기 때문에 === 사용해 판단해야 함

### 실행 컨텍스트
**실행컨텍스트란?**
실행할 코드에 제공할 환경정보들을 모아놓은 객체로 자바스크립트의 동적언어로써의 셩격을 가장 잘 파악 할 수 있는 개념
실행 컨텍스트가 활성화되는 시점에
선언된 변수를 위로 끌어올리고 (호이스팅)
외부환경정보를 구성하고 
this의 값을 설정함
**이로 인해 다느 언어에서는 발견할 수 없는 특이현상이 발생**
실행컨텍스트는 각 함수마다 따로 존재한다 함수가 호출될때 생성
함수 호출 스택에서 함수의 실행이 완료될때마다 순차적으로 소멸함

- 스택
출입구가 하나밖에 없는 깊은 우물 같은 데이터 구조 LIFO(Last in First out)
저장할 수 있는 용량이 있어 그 이상을 저장할려고 하면 넘친다-> 에러

- 큐
양쪽이 모두 열려있는 파이프 FIFO(First in First out)

실행컨텍스트는 **실행할 코드에 제공할 환경정보를 모아놓은 객체** 
동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보를 모아 구성
이를 콜스택ㄹㅇ에 쌓아올렸다가 가장 위에 있는 컨텍스트 관련 코드를 실행하는 식
하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, eval()함수 함수가 있음
자동으로 생성되는 전역공간과 악마라고 평가받는 eval()을 제외 => 흔히 구성하는 방법은 함수밖에 없음
```javascript
// ---- 1번
var a = 1;
function outer() {
	function inner() {
		console.log(a); //undefined
		var a = 3;
	}
	inner(); // ---- 2번
	console.log(a);
}
outer(); // ---- 3번
console.log(a);
```
지금은 콜스텍에 어떻게 쌓이고 어떤 순서대로 실행에 관여하는지만 알면된다 
처음 자바스크립트 실행하는 순간(1번) 전역 컨텍스트가 담김
(전역 컨텍스트는 일반적인 실행 컨텍스트와 비슷 )
최상단의 공간은 코드 내부에서 별도의 실행 명령이 없어도 브라우저에서 자동으로 실행하기 때문에 파일이 열리는 순간 전역 컨텍스트가 활성화 된다

콜스텍에는 전역 말고 다른 덩어리가 없기 때문에 전역과 관력된 코드를 진행하다가 
(3)에서 outer함수를 호출하면 자바스크립트엔진은 이 outer에 대한 정보를 수집해서 실행 컨텍스트 생성 후 콜 스택에 담음

스택이므로 위에 쌓임 -> 전역을 중지하고 outer를 먼저실행(LIFO 여서)
근데 지금 outer의 생성 부분 보니까 안에 inner를 생성하고 inner를 실행
그래서 위에 inner가 쌓고 inner를 먼저 실행
콘솔로그 a
*
(이게 undefined인 console.log(a)가 undefined를 출력하는 이유는 JavaScript의 변수 호이스팅 때문
inner() 함수 내에서의 var a 선언이 외부 스코프의 전역 변수 a를 참조하는 것이 아니라, 새로운 지역 변수 a를 선언
아래 있지만 변수 호이스팅으로 인해 선언부분이 위로 올라가고 콘솔로그 하고 그 다음 할당
inner() 함수 내에서의 a는 외부 스코프의 전역 변수 a와는 별개의 변수)

코드 실행 전에 변수 선언이 메모리에 할당
inner가 내부 의 a함수의 3을 할당하고 종료
그 후 아래있던 outer함수의 console.log(a)실행(2)
이건 선언한 값이 없어 전역 참조해 1이 나옴 그리고 종료
마지막으로 전역컨텍스트가 console.log(a)을 해 종료

**한 실행 컨텍스트가 콜 스택의 맨위로 쌓이는 순간 현재 실행할 코드에 관여하게 되는 시점**

실행 컨텍스트에 담기는 정보
1. VariableEnvironment
현재 컨텍스트내의 식별자들에 대한 정보(EnvironmentRecord) +
외부환경 정보+
선언시점의 LexicalEnvironment 스냅샷

2. LexicalEnvironment
처음은 VariableEnvironment와 동일하지만 변경사항이 실시간으로 반영됨

3. ThisBinding
식별자가 바라봐야 할 대상 객체



* 스냅샷이란?
스냅샷이라는 용어는 상태를 기록하고 저장하는 것을의미
컴퓨터 과학에서는 주로 현재 상태를 캡쳐하고 기록하는 용어 
스냅샷은 특정 시점의 상태를 나타냄-> 이용해 복원이나 특정 시점을비교 분석
선언시점의 LexicalEnvironment 스냅샷은 이때의 상태를 기록한것
상태란 해당 실행 컨텍스트 내에서 사용이 가능한 식별자들과 그들의 값을 포함하는 환경


-  VariableEnvironment
 LexicalEnvironment와 같지만 최초 실행시의 스냅샷을 유지한다는 점이 다름
 실행 컨텍스트 생성시 VariableEnvironment의 정보를 담고 이를 복사해  LexicalEnvironment만든후 이 후에는  LexicalEnvironment 주로 사용
 <br></br>
 
 - LexicalEnvironment
 한국어 번역이 문서 마다 다른데 '어휘적 환경'이라는 단어가 많이 등장
 근데 이건 별로 와닿지 않음
 사전적인이 더 어울리는 표현
 현재 컨텍스트 내부에는 식별자들이 있고 어떻게 하도록 구성이 되어있다 라는 환경정보를
 사전에서 접하는 느낌으로 모아놓은것
 다른점은 실시간으로 변경 사항이 계속해서 반영된다는 점
 
 ### EnvironmentRecord와 호이스팅
 
EnvironmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장됨
컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 
그 함수 자체, var로 선언된 변수의 식별자등이 식별자에 해당
컨텍스트 내부를 **순서대로** 수집

정보를 수집하는 과정을 모두 맞혔더라도 아직 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태
실행되기 전에도 불구하고 이미 정보를 다 수집했기때문에 자바스크립트 엔진은 해당 환경에 속한 코드의 변수명을 모두 일고 있게됨

이때 호이스팅이라는 개념이 등장

- **호이스팅**이란?
끌어올리다라는 의미로 hoist에 ing를 붙여 만든 동명사 
변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상개념 
실제로 끌어올리지는 않지만 편의상 끓어올린것으로 간주하자는 것

- 호이스팅의 규칙

```javascript
function a (x) {
	console.log(x);
	var x;
	console.log(x);
	var x = 2;
	console.log(x);
}
a(1);
```
매개변수 적용
```javascript
function a () {
	var x = 1;
	console.log(x);
	var x;
	console.log(x);
	var x = 2;
	console.log(x);
}
a(1);
```
호이스팅은 현재실행될 컨텍스트의 대상 코드내에 어떤 식별자들이 있는지에만 관심있고 어떤 값이 할당될 것인지에는 관심 없음
따라서 변수를 호이스팅할때 변수명만 끌어올리고 할당과정은 그 자리에 넘겨놓음
```javascript
function a () {
	var x;
	var x;
	var x;

	x = 1;
	console.log(x);
	console.log(x);
	x = 2;
	console.log(x);
}
a(1);
```
x의 선언이 다 위로 올라오고 값은 그자리에

- 실제 코드 실행 순서
1. 함수 a를 선언 메모리에 저장할 공간확보하고 a를 저장
2. 변수 x를 선언하고 주소값에 x를 연결
3. 변수 x를 선언하는데 이미 선언된 변수가 있으니 무시(2번 일어남)
4. 변수 x에 1을 할당 숫자 1을 별도의 메모리에 담고 x와 연결된  메모리 공간에 숫자 1을 가리키는 주소값 입력
5. 1 출력(2번 실행 됨)
6. 2를 할당하라고 함 2의 값을 별도의 주소값에 넣고 x랑 연결된 메모리 값으로 가 주솟값을 대치(하지만 이때도 a의 주소값은 바뀌지 않음)
7. 2를 출력
8. 종료되서 실행 컨텍스트 제거 

예제를 하나더 추가해서 보자 
중요한 점은 선언은 관심이 있어서 가장 위로 올리지만 값 할당은 그 자리 그대로 존재 한다는 점

```javascript
function a () {
	console.log(b);
	var b = 'bbb';
	console.log(b);
	function b() { }
	console.log(b);
}
a();
```
내 생각으로는 b 선언이 위로 올라가고 
```javascript
function a () {
  	var b;
  	var b = function b() { };
	console.log(b); //b
	var b = 'bbb';
	console.log(b);//bbb
	//아무것도 없음
	console.log(b);//bbb
}
a();
```
라고 생각함

a함수를 실행하는 순간 a 함수의 실행 컨텍스트가 생성 
**이 때 변수명과 선언부를 위로 끌어올리는 것처럼 수집**
함수선언문은 함수명으로 선언한 변수에 함수를 할당한것 처럼 여길 수 있다

- 실행 순서 
1. a를 실행스택에 넣는다 
2. 변수 b를 선언하고 메모리에 공간을 확보하고 확보한 공간의 주소값을 연결한다
3. 다시 변수 b를 선언인데 이미 있으니 선언은 안하고 주소값에 연결된 값을 함수의 주소값으로 바꿈
4. b함수를 출력
5. b에 bbb할당
6. 출력 2번


### 함수선언문과 함수 표현식
호이스팅을 다루는 김에 알아두면 좋을 내용을 소개
함수선언문과 함수 표현식
둘 모두 함수르 새롭게 정의 할때 쓰이지만 
**함수 선언문은 function 정의부만 존재하고 별도의 할당 명령어는 없는 것을 의미**
**함수 표현식은 정의한 function이 별도의 함수에 할당하는 것을 말함**

```javascript
// 함수 선언문. 함수명 a가 곧 변수명
// function 정의부만 존재, 할당 명령이 없는 경우
function a () { /* ... */ }
a(); // 실행 ok

// 함수 표현식. 정의한 function을 별도 변수에 할당하는 경우
// (1) 익명함수표현식 : 변수명 b가 곧 변수명(일반적 case에요)
var b = function () { /* ... */ }
b(); // 실행 ok

// (2) 기명 함수 표현식 : 변수명은 c, 함수명은 d
// d()는 c() 안에서 재귀적으로 호출될 때만 사용 가능하므로 사용성에 대한 의문
var c = function d () { /* ... */ } 
c(); // 실행 ok
d(); // 에러!
```
기명함수 표현법은 외부에서 함수명으로 호출할 수 없다는 점
과거에는 기명함수 표현법이 잘 출력됐었는데 반면 익명함수표현법은 unnamed나 undefined가 나왔음
이 때문에 기명함수표현법은 익명함수 표현법보다 디버깅 시 어떤 함수인지 추적하기에 보다 유리 했지만 현재는 다 변수명을 함수의 name 프로퍼티에 할당
한편 c내부에서는 c()로 호출 하든 d()로 호출하든 잘 실행되서 재귀함수로써 쓸 수는 있지만 굳이 c가 되는데 d를 쓸 필요가 있을지는 의문

- 실질적인 차이

``` javascript
console.log(sum(1, 2));
console.log(multiply(3, 4));

function sum (a, b) { // 함수 선언문 sum
	return a + b;
}

var multiply = function (a, b) { // 함수 표현식 multiply
	return a + b;
}
```
일단 실행되면 실행컨텍스트에서 정보수집(호이스팅 됨)
```javascript
// 함수 선언문은 전체를 hoisting
function sum (a, b) { // 함수 선언문 sum
	return a + b;
}

// 변수는 선언부만 hoisting

var multiply; 

console.log(sum(1, 2));
console.log(multiply(3, 4));

multiply = function (a, b) { // 변수의 할당부는 원래 자리
	return a + b;
};
```
함수 선언문은 전부 호이스팅 했지만 함수 표현식은 변수 선언 부분만 호이스팅 됨
함수도 하나의 값으로 취급 할 수 있다는 것이 바로 이런것
**함수를 다른 변수의 값으로 할당한 것이 바로 함수 표현식**
여기서 차이가 생긴다
만약 
multiply를함수 선언문으로 했으면 전부 올라가서 함수가 선언됐겠지만 함수 표현식은 변수 부분만 호이스팅 되어 에러가 난다

개발자 A가 함수를 선언 단순한 함수로 거대한 자바스크립트 파일의 100번째줄에 존재 
이 함수를 여기저기 호출해서 잘 사용함
그런데 어느날 신입이 5000줄에 같은 이름으로 새로운 내용의 함수를 함수 선언문으로 사용 
이렇게 되면 호이스팅되어 변수가 위로 올라가기 때문에 오류가 난다
``` javascript
...

console.log(sum(3, 4));

// 함수 선언문으로 짠 코드
// 100번째 줄 : 시니어 개발자 코드(활용하는 곳 -> 200군데)
// hoisting에 의해 함수 전체가 위로 쭉!
function sum (x, y) {
	return x + y;
}

...
...

var a = sum(1, 2);

...

// 함수 선언문으로 짠 코드
// 5000번째 줄 : 신입이 개발자 코드(활용하는 곳 -> 10군데)
// hoisting에 의해 함수 전체가 위로 쭉!
function sum (x, y) {
	return x + ' + ' + y + ' = ' + (x + y);
}

...

var c = sum(1, 2);

console.log(c);
```
여기서 보면 전혀 다른 문자열을 반환하게 됐다 
하지만 정작 문제인 새로 만든 sum 함수는 오류도 나지 않고 잘못된 값이여도 암묵적인 형변환 때문에 오류 없이 통과
둘다 함수 표현식으로 사용했다면 그 아래부터 잘 됐을것
**상대적으로 함수 표현식이 안전**

### LexicalEnvironment(2) - 스코프, 스코프 체인, outerEnvironmentReference(=outer)

- 스코프란?
식별자에 대한 유효범위 
전역에서 선언한 변수는 어디에서나 접근이 가능하지만 영역 a에서 만든 변수는 a에서만 접근이 가능
es5까지의 자바스크립트는 특이하게 전역공간을 제외하면 오직 함수에 의해서만 스코프가 생성
(es6부터 블록에 의해서도 스코프 경계가 발생하게 되면서 다른 언어와 비슷해짐
다만 var가 아닌 let, const, strict mode에서의 함수, 변수 선언에 한해서만
이를 구분하기 위해 '함수 스코프', '변수 스코프'라고 함

어쨌든 이런 식별자의 유효범위를 안에서부터 바깥으로 차례대로 검색해 나가는 것을 스코프 체인이라고 함![](https://velog.velcdn.com/images/soijeongg/post/d5cb6dd4-9b92-4396-8d25-e93da07bf83b/image.png)

**그리고 이를 가능케 하는것이 LexicalEnvironment의 두번째 수집자료인 outerEnvironmentReference**
(외부환경의 참조정보)


- 스코프 체인
outerEnvironmentReference는 현재 호출된 함수가 선언될 당시(과거시점)의 LexicalEnvironment를 참조(환경정보를 저장)

선언하다라는 행위가 일어날 수 있는 시점이란 콜 스텍 상에 어떤 실행컨텍스트가 활성화 된 상태 일때뿐

예를 들어, A함수 내부에 B함수 선언 → B함수 내부에 C함수 선언(Linked List)한 경우
함수 c의 outerEnvironmentReference는 b의 outerEnvironmentReference참조
b는 다시 선언됐을 당시의 a의 outerEnvironmentReference 참조 
a는 전역의 outerEnvironmentReference 참조

**이렇게 올라가자보면 결국 끝은 전역의 outerEnvironmentReference참조**

또한 각 outerEnvironmentReference는 오직 자신이 선언된 시점의 LexicalEnvironment만을 참조하고 있으므로 가장 가까운 요소부터 차례대로 접근하고 다른 순서로 접근은 불가능
따라서 동일한 식별자를 생성한 경우 무조건 스코프 체인상에서 가장 먼저 발생한 식별자에만 접근이 가능

### this(정의, 활용방법, 바인딩, call, apply, bind)
원래 객체지향 언어에서 this는 클래스로 선언한 인스턴스를 말함
그러나 **자바스크립트는 this가 어디에서나 사용될 수 있음**

- 실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체이다.
- 그 객체 안에는 3가지가 존재한다.
   ✓ VariableEnvironment
   ✓ LexicalEnvironment
 <span style="color: red">  ✓ ThisBindings</span>

1. 상황에 따라 this가 달라지는 this
상황에 따라 this가 바라보는 대상이 달라지는데 어떠한 이유로 그렇게 되는지를 파악하기 힘든 경우도 있고 
예상과 달리 엉뚱한 대상을 바라보는 경우도 있다
함수와 객체의 구분이 느슨한 자바스크립트에서 this는 실질적으로 둘을 구분하는 거의 유일한 기능

this는 기본적으로 실행컨텍스트가 생성될때 결정
함수가 호출될떄 생성되므로 바꿔말하면 함수를 호출할때 결정된다
**함수를 어떤 방식으로 호출하느냐에따라 값이 달라짐**

1. 전역공간에서 this
전역공간에서 this는 전역객체를 가르킴
왜냐하면 개념 상 전역 컨텍스트를 생성하는 주체가 전역 객체이기 때문
전역 객체가 자바스킯트 런타임 환경에 따라 다른 이름과 정보를 가지고 있는데 브라우저 환경에서 전역객체는 window node.js에서는 global
브라우저 환경
```javascript
console.log(this);
console.log(window);
console.log(this === window);
````
노드 환경
```javascript
console.log(this);
console.log(global);
console.log(this === global);
```
this와는 크게 상관없지만 전역공간을 다루는 김에 잠시 전역 공간에서 발생하는 특이한 성질
전역변수는 선언하면서 자바스크립트 엔진은 이를 전역 객체의 프로퍼티로 할당
**변수이면서 객체의 프로퍼티**
자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로서 동작
사용자가 var연산자를 이용해 변수 선언 하더라도 자바스크립트 엔진은 어떤 특정 객체의 프로퍼티로 인식
w

- 특정 객체란?
LexicalEnvironment(L,E)
실행컨텍스트는 변수를 수집해서 LE의 프로퍼티의 저장 이후 변수 호출시 LE조회 일치하는 변수 있을 경우 그 값을 반환
**전역변수를 선언하면 이를 자바스크립트 엔진은 전역객체의 프로퍼티로 할당한다**

2. 메서드로서 호출할 때 그 메서드 내부에서의 this
a. 함수 vs 메서드
함수를 실행하는 방법 중 가장 일반적인 것은 함수로서 호출하는 것과 메서드로 호출하는 경우 
함수와 메서드는 둘다 미리 정의한 동작을 수행하는 코드뭉치로 둘의 유일한 차이는 **독립성**에 있음

함수는 그자체의 독립적인 기능을 수행
메서드는 자신을 호출한 대상 객체에 관한 동작을 수행
<span style="color:red">자바스크립트는 상황별로 this키워드에 다른 값을 부여 함으로써 구현</span>

- 함수내부에서의 this

어떤 함수를 함수로써 호출할 경우 this는 지정x(호출 주체를 알 수 없음)
실행컨텍스트를 활성화할 당시 this가 지정되지 않은 경우, this는 전역 객체 의미
함수로서 ‘독립적으로’ 호출할 때는 this는 항상 전역객체를 가리킨다
변수에 담아 호출한 경우와 객체에 감아 호출한 경우는 this가 달라지게 된다
 **구분하는 방법**
 함수 앞에 점이 있는지 없는지 여부로 구분 가능(물론 대괄호 표기법도 가능)
 어떤 함수를 호출할때 그 함수의 이름(프로퍼티) 앞에 객체가 명시돼 있는 경우에는 메서드로 호출, 그렇지 않은건 함수
 

- 메서드의 내부함수
this에는 호출한 주체에 대한 정보가 담김 메서드로서 호출시 호출 주체는 바로 함수명(프로퍼티 )앞 객체
메서드의 내부라도 하더라도 함수로써 호출 시 this는 전역객체를 의미 

함수 내부에서의 this
어떤 함수를 함수로서 호출할 경우에는 this가 지정x 
this에는 호출한 객체의 정보가 담김 그런대 함수로서 호출하는 것은 호출 주체를 명시하지 않고 **개발자가 코드에 관여해서 실행한것이여서 알 수 없다**

실행컨텍스트를 활성화당시 this가 지정되지 않는 경우는 전역을 바라봄-> 그래서 함수의 this는 전역객체


```javascript
var obj1 = {
	outer: function() {
		console.log(this); // (1)
		var innerFunc = function() {
			console.log(this); // (2), (3)
		}
		innerFunc();

		var obj2 = {
			innerMethod: innerFunc
		};
		obj2.innerMethod();
	}
};
obj1.outer();
```
1번은 this가 obj를 가리킴
2번은 함수가 독립적으로 수행-> this(그냥 함수가 표현식으로 정의 되서 그렇게 된다라고 생각)
3번은obj2의 메서드 obj2


지금보면 같은 함수인데도 innerFunc();와 obj2.innerMethod();는 서로 this가 정의하는 부분이 달라짐
그러니까 함수를 실행하는 당시의 주변환경(메서드 인지 함수 내부 환경인지는 중요하지 않고 
**오직 해당 함수를 호출하는 구문 앞에 .or []가 있는지 없는지가 중요**
#### this 우회 

- 메서드 내부 함수에서의 this를 우회하는 방법
this에 대한 구분은 명확히 할 수 있지만 this라는 단어가 주는 인상과 달라짐
호출주체가 없을을때는 호출 당시의 주변 환경의 this를 그대로 상속받아 사용할 수 있다면 좋겠다
이게 훨씬 자연스럽고 스코프체인과의 일관성을 지키는 설득력있는 방식

**하지만 다행히 이를 우회할 방법은 있다**

- 변수를 활용하는 방법
내부 스코프에 이미 존재하는 this를 별도의 변수(ex : self)에 할당
```javascript
var obj1 = {
	outer: function() {
		console.log(this); // (1) outer

		// AS-IS
		var innerFunc1 = function() {
			console.log(this); // (2) 전역객체
		}
		innerFunc1();

		// TO-BE
		var self = this; //this를 저장
		var innerFunc2 = function() {
			console.log(self); // (3) outer
		};
		innerFunc2();
	}
};

// 메서드 호출 부분
obj1.outer();
```
지금 보면 원래 2번은 점 없이 호출이 됐기 때문에 전역객체를 가르킨다 
하지만 outer 스코프에서 self라는 변수에 this를 저장한 상태에서 호출한경우 self에는 객체가 들어감
self는 그저 상위 스코프의 this를 저장해서 내부함수에 활용하려는 수단 의미만 통한다면 변수명은 무엇으로 정해도 무관

- this를 바인딩 하지 않는 함수
es6에서 함수내부의 this가 전역객체를 바라보는 문제를 보완하고자 this를 바인딩 하지 않는 화살표 함수 도입
화살표함수는 실행컨텍스트를 생성할때 this바인딩 과정 자체가 빠지게 되어 상위스코프의 this를 그대로 활용
```javascript
var obj = {
	outer: function() {
		console.log(this); // (1) obj
		var innerFunc = () => {
			console.log(this); // (2) obj
		};
		innerFunc();
	}
}

obj.outer();
```

- 콜백함수호출 시 그 함수  내부에서의 this

콜백함수란?
어떠한 함수 메서드의 매개변수로 넘겨주는 함수
함수a의 제어권을 함수 또는 메서드 b에 넘겨주는 경우를 함수 a를 콜백 함수라고 함
이때 함수 a는 함수 b의 내부 로직에 따라 실행
this 역시 b내부의 규칙에 따름

**콜백함수도 함수이기에 전역객체를 참조하지만 제어권을 받은 함수에서 별도로 this가 될 대상을 지정한 경우 에는 그 대상 참조**

```javascript
// 별도 지정 없음 : 전역객체
setTimeout(function () { console.log(this) }, 300);

// 별도 지정 없음 : 전역객체
[1, 2, 3, 4, 5].forEach(function(x) {
	console.log(this, x);
});

// addListener 안에서의 this는 항상 호출한 주체의 element를 return하도록 설계되었음
// 따라서 this는 button을 의미함
document.body.innerHTML += '<button id="a">클릭</button>';
document.body.querySelector('#a').addEventListener('click', function(e) {
	console.log(this, e);
});
```
setTimeoutsms 300ms만큼 시간을 지연한 뒤 콜백 함수를 실행하라는 명령
-> 0.3초 뒤 전역객체가 출력

addEventListner 메서드는 콜백 함수 호출 시, 자신의 this를 상속하므로, this는 addEventListner의 앞부분(button 태그)

(addEventListner는 지정한 html엘리멘트에 이벤트가 발생할때마다 그 이벤트의 정보를 첫번째 콜백함수의 첫번쨰 인자로 삼아 함수를 실행하라는 의미)
-> 콜백함수 호출 시 자신의 this를 상속하도록 정의 되어 있음

- 생성자 함수 내부에서의 this
생성자 함수란?
어떤 공통된 성질을 지니는 객체들을 생성하는데 사용하는 함수
객체지향언어에서는 생성자를 클래스 
클래스를 통해 만든 객체를 인스턴스 
이거는 붕어빵 틀(클래스)과 붕어빵(인스턴스)로 생각하면 됨

자바스크립트는 함수에 생성자로서의 역할을 함께 부여 (new 명령어와 함께 함수호출)
어떤 함수가 생성자로 호출된 경우 내부의 this는 새로 만들 구체적인 인스턴스가 됨

생성자 함수를 호출 시 우선 생성자의 프로토타입 프로퍼티를 참조하는 _proto_라는 프로퍼티가 있는 객체를 만들고 미리 준비된 공통 속성 및 개성을 해당 객체에 부여 

```javascript
var Cat = function (name, age) {
	this.bark = '야옹';
	this.name = name;
	this.age = age;
};

var choco = new Cat('초코', 7); //this : choco
var nabi = new Cat('나비', 5);  //this : nabi
```
cat이라는 변수에 익명함수 할당 -> 함수내부에서 this에 접근해 프로퍼티에 각각의 값을 대입

그 후 new 명령어를 사용해 각각 할당

### 명시적 this 바인딩
상황별로 this에 어떤 값이 바인딩 되는지 살펴봤지만 이러한 규칙을 깨고 this에 별도의 대상을 바인딩 하는 방법

1. call메서드 
```javascript
function.prototype.call(thisArg[, arg1[,arg2[,...]]])
```
call 메서드는 호출 주체인 함수를 즉시 실행하라는 명령
메서드의 첫번째 인자를 this로 바인딩
이후 인자들은 호출할 함수의 매개변수로 실행
**함수를 그냥 실행하면 this는 전역객체를 참조하지만 call메서드를 이용하면 임의의 객체를 this로 지정가능**
```javascript
var func = function (a, b, c) {
	console.log(this, a, b, c);
};

// no binding
func(1, 2, 3); // Window{ ... } 1 2 3

// 명시적 binding
// func 안에 this에는 {x: 1}이 binding돼요
func.call({ x: 1 }, 4, 5, 6}; // { x: 1 } 4 5 6
```
메서드에 대해서도 마찬가지로 객체의 메서드를 그냥 호출할려고 하면 this는 객체를 가르키지만 call메서드 사용시 임의의 객체 지정 가능
```javascript
var obj = {
	a: 1,
	method: function (x, y) {
		console.log(this.a, x, y);
	}
};

obj.method(2, 3); // 1 2 3
obj.method.call({ a: 4 }, 5, 6); // 4 5 6
```

2. apply메서드 
call과 기능적으로 동일 this에 binding할 객체는 똑같이 넣어주고
apply는 두번째 인자를 배열로 받아 그 배열의 요소를 호출 할 함수의 매개변수로 지정한다 
```javascript
var func = function (a, b, c) {
	console.log(this, a, b, c);
};
func.apply({ x: 1 }, [4, 5, 6]); // { x: 1 } 4 5 6

var obj = {
	a: 1,
	method: function (x, y) {
		console.log(this.a, x, y);
	}
};

obj.method.apply({ a: 4 }, [5, 6]); // 4 5 6
```

3.call / apply 메서드 활용
유사배열객체(array-like-object)에 배열 메서드를 적용![](https://velog.velcdn.com/images/soijeongg/post/814af92a-9a1f-40c4-8fbc-864e63321adf/image.png)
```javascript
//객체에는 배열 메서드를 직접 적용할 수 없어요.
//유사배열객체에는 call 또는 apply 메서드를 이용해 배열 메서드를 차용할 수 있어요.
var obj = {
	0: 'a',
	1: 'b',
	2: 'c',
	length: 3
};
Array.prototype.push.call(obj, 'd');
console.log(obj); // { 0: 'a', 1: 'b', 2: 'c', 3: 'd', length: 4 }

var arr = Array.prototype.slice.call(obj);
console.log(arr); // [ 'a', 'b', 'c', 'd' ]
```
객체에는 배열 메서드를 바로 적용할 수 없다
그러나 키가 ()또는 양의 정수인 프로퍼티가 존재하고 length프로퍼티의 값이 0또는 양의 정수인 객체 즉 배열의 구조와 유사한 객체 **유사배열객체**인 경우 call, apply 사용 가능

배열 메서드인 push를 객체인 obj에 적용해 프로퍼티에 3에 d 추가
배열이 아닌 객체에 사용하기 위해 this에 임의의 객체 할당
원래 배열메서드는 가르키는 this에 동작함(.뒤에)

slice 메서드를 사용해 객체를 배열로 만듬
slice는 매개변수를 아무것도 넘기지 않을 경우 그냥 원본배열의 얉은복사본을 반환
근데 원래 slice는 배열메서드이니까 call사용

함수 내부에서 접근 할 수 있는 argument객체도 유사배열 객체이므로 위와 같은 방법으로 전환 가능

그밖의 유사배열 객체에도 사용가능하지만 문자열인 경우 lengthrk 읽기 전용이기 때문에 원본 문자열에 변경을 가하는 메서드(pop, push, unshift 등)

2. Array.from 메서드(ES6)
    
    사실, call/apply를 통해 this binding을 하는 것이 아니라 **`객체 → 배열`**로의 형 변환 만을 위해서도 쓸 수 있지만 원래 의도와는 거리가 먼 방법.
- Array.from
```javascript
// 유사배열
var obj = {
	0: 'a',
	1: 'b',
	2: 'c',
	length: 3
};

// 객체 -> 배열
var arr = Array.from(obj);

// 찍어보면 배열이 출력됩니다.
console.log(arr);
```

3.생성자 내부에서 다른 생성자를 호출
생성자 내부에 다른 생성자와 공통된 내용이 있을경우 call 또는 apply를 이용해 다른 생성자 호출하면 간단히 반복을 줄일 수 있다
```javascript
function Person(name, gender) {
	this.name = name;
	this.gender = gender;
}
function Student(name, gender, school) {
	Person.call(this, name, gender); // 여기서 this는 student 인스턴스!
	this.school = school;
}
function Employee(name, gender, company) {
	Person.apply(this, [name, gender]); // 여기서 this는 employee 인스턴스!
	this.company = company;
}
var kd = new Student('길동', 'male', '서울대');
var ks = new Employee('길순', 'female', '삼성');
```

Student, Employee 모두 Person입니다. name과 gender 속성 모두 필요

Student와 Employee 인스턴스를 만들 때 마다 세 가지 속성을 모두 각 생성자 함수에 넣기 보다는 Person이라는 생성자 함수를 별도로 빼는게 ‘구조화’에 도움

call() 메서드를 사용하여 Person 함수를 호출
this를 전달하여 Person 함수 내에서의 this가 Student 인스턴스
생성자 함수 생성시 this가 새로 만들 구체적인 인스턴스가 됨
그리고 여기 안에 person.call해서 첫번째인 this를 person의 this로 만드는데 이 생성자의 this가 인스턴스여서 위의 person의 this도 그 인스턴스가 됨 
그래서 새롭게 만든 인스턴스에 this가 같으니까 사용이 가능해짐
그래서 **상속**
(이거 차라리 자바의 extend가 더 이해 편함, 파이썬의 상속이 더 편함)

이렇게 하면 상속가능
(상속을 왜 이렇게???? 어쩃든 이해 됨)

4.여러 인수를 묶어 하나의 배열로 전달할 때 apply 사용
여러개의 인수를 받는 메서드에게 하나의 배열로 인수들을 전달하고 싶을때 apply메서드를 사용하면 편함

Math.max는 파라미터로 여러 값을 받는데 배열을 주면 nan을 반환
gpt가 
Math.max() 메서드는 여러 개의 숫자를 인수로 받아 가장 큰 숫자를 반환합니다. 하지만 배열을 직접 전달하면 원하는 결과를 얻을 수 없습니다. 예를 들어, 다음과 같이 배열을 직접 전달하면 원하는 결과를 얻지 못합니다.

할꺼면 전개연산자로 펼치던가
var max = Math.max.apply(null, numbers);
이렇게 pply() 메서드를 사용하여 배열의 요소들을 함수의 인수로 전달하는 것이기 때문에 가능

call/apply는 명시적으로 this를 바인딩 하면서 함수또는 메서드를 실행하는 훌룡한 방법이지만 오히려 this를 에측하기 힘들어 코드 해석을 방해

4. bind 메서드
ES5에 추가된 기능
all과는 다르게 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하는 메서드
다시 새로운 함수를 호출할때 전달했던 인수들 뒤를 이어 등록
bind는 함수에 **this를 미리 적용하는 것**과 **부분 적용 함수를 구현**하는 두가지 목적을 지님

```javascript
var func = function (a, b, c, d) {
	console.log(this, a, b, c, d);
};
func(1,2,3,4); // window 1,2,3,4
var bindFunc = func.bind({ x:1 }, 4, 5);

bindFunc(5,6,7,8) //{x=1},4,5,5,6,7,8
// func와 bindFunc의 name 프로퍼티의 차이를 살펴보세요!
console.log(func.name); // func
console.log(bindFunc.name); // bound func
```
JavaScript에서 함수의 name 프로퍼티는 해당 함수의 이름
bind 메서드를 적용해서 새로 만든 함수는 name 프로퍼티에 ‘bound’ 라는 접두어
바인딩된 함수가 기존 함수에 대한 래퍼(wrapper) 역할

`var bindFunc = func.bind({ x:1 }, 4, 5);
`여기에서 this에 x:1로 지정 

- 상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기
self등을 활용한 우회법보다 더 깔끔 하게 처리 가능
```javascript
var obj = {
	outer: function() {
		console.log(this); // obj
		var innerFunc = function () {
			console.log(this);
		};

		// call을 이용해서 즉시실행하면서 this를 넘겨주었습니다
		innerFunc.call(this); // obj
	}
};
obj.outer();
```
원래 함수는 전역객체를 보는데 지금 call로 즉시 실행하면서 첫번째 인자인 this를 넘겨줌
지금 obj.outer();실행 거기서 outer보니까 안에 call이 있으니까 제일 먼저 실행 여기서 this가 보니까 obj여서 넘겨줌
그래서 두번째 실행이 되는 console.log(this)에 obj가 됨
```javascript
var obj = {
	outer: function() {
		console.log(this);
		var innerFunc = function () {
			console.log(this);
		}.bind(this); // innerFunc에 this를 결합한 새로운 함수를 할당
		innerFunc();
	}
};
obj.outer();
```
outer가 먼저 호출 그럼 outer를 보는데 여긴 call이 없으니까 먼저 위부터 console.log(this)인데 함수가 객체의 메서드로서 사용 그래서 this가 obj가 됨 그 후 bind되어서 
bind(this)는 innerFunc 함수가 호출될 때의 this를 설정하는 것
innerFunc 함수의 정의 이전에 bind(this)가 호출
메서드가 호출된 시점에서의 this 값

또한 콜백 함수를 인자로 받는 함수나 메서드 중에서 기본적으로 콜백함수내에서 this에 관여하는 함수또는 메서드에 관해서도 bind메서드 이용시 this값을 사용자의 입맛에 맞게 바꿀 수 있음

콜백함수도 함수이기 때문에, 함수가 인자로 전달될 때는 함수 자체로 전달(this가 사라짐, 이걸 bind 사용가능)

```javascript
var obj = {
	logThis: function () {
		console.log(this);
	},
	logThisLater1: function () {
		// 0.5초를 기다렸다가 출력해요. 정상동작하지 않아요.
		// 콜백함수도 함수이기 때문에 this를 bind해주지 않아서 잃어버렸어요!(유실)
		setTimeout(this.logThis, 500);
	},
	logThisLater2: function () {
		// 1초를 기다렸다가 출력해요. 정상동작해요.
		// 콜백함수에 this를 bind 해주었기 때문이죠.
		setTimeout(this.logThis.bind(this), 1000);
	}
};

obj.logThisLater1();
obj.logThisLater2();
```

5.화살표 함수의 예외사항
화살표 함수는 실행 컨텍스트 생성 시, this를 바인딩하는 과정이 제외
 this의 할당과정(바인딩 과정)이 아에 없으며, 접근코자 하면 스코프체인상 가장 가까운 this에 접근하게 됨
 ```javascript
var obj = {
	outer: function () {
		console.log(this);
		var innerFunc = () => {
			console.log(this);
		};
		innerFunc();
	};
};
obj.outer();
```
이러면 먼저 obj.outer(); 실행 그럼 여기에 가서 위에서부터 하는데 함수가 객체의 메서드로서 사용되서 this가 obj
그후 아래 innerFunc정의 되고 실행되는데 어차피 없으니까 가장 가까운 this obj한테 감